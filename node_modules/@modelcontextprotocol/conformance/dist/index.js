#!/usr/bin/env node
import{Command as e}from"commander";import{ZodError as t,z as n}from"zod";import{spawn as r}from"child_process";import{promises as i}from"fs";import a from"path";import o from"http";import{Server as s}from"@modelcontextprotocol/sdk/server/index.js";import{StreamableHTTPServerTransport as c}from"@modelcontextprotocol/sdk/server/streamableHttp.js";import{CallToolRequestSchema as l,CallToolResultSchema as u,CreateMessageRequestSchema as d,ElicitRequestSchema as f,ElicitResultSchema as p,ErrorCode as m,ListToolsRequestSchema as h,LoggingMessageNotificationSchema as g,McpError as _,ProgressNotificationSchema as v}from"@modelcontextprotocol/sdk/types.js";import y from"express";import{createHash as b,randomUUID as x}from"crypto";import{Client as S}from"@modelcontextprotocol/sdk/client/index.js";import{StreamableHTTPClientTransport as C}from"@modelcontextprotocol/sdk/client/streamableHttp.js";import{EventSourceParserStream as w}from"eventsource-parser/stream";import{request as ee}from"undici";import{requireBearerAuth as te}from"@modelcontextprotocol/sdk/server/auth/middleware/bearerAuth.js";import*as T from"jose";import{parse as ne}from"yaml";var re=Object.defineProperty,ie=(e=>{let t={};for(var n in e)re(t,n,{get:e[n],enumerable:!0});return t})({createClientInitializationCheck:()=>oe,createServerInfoCheck:()=>ae});function ae(e){return{id:`server-info`,name:`ServerInfo`,description:`Test server info returned to client`,status:`INFO`,timestamp:new Date().toISOString(),specReferences:[{id:`MCP-Lifecycle`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle`}],details:{serverName:e.name,serverVersion:e.version}}}const E=[`2025-06-18`,`2025-11-25`];function oe(e,t=`2025-11-25`){let n=e?.protocolVersion,r=(E.includes(t)?E:[...E,t]).includes(n),i=[];return n||i.push(`Protocol version not provided`),r||i.push(`Version mismatch: expected ${t}, got ${n}`),e?.clientInfo?.name||i.push(`Client name missing`),e?.clientInfo?.version||i.push(`Client version missing`),{id:`mcp-client-initialization`,name:`MCPClientInitialization`,description:`Validates that MCP client properly initializes with server`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[{id:`MCP-Lifecycle`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle`}],details:{protocolVersionSent:n,expectedSpecVersion:t,versionMatch:r,clientName:e?.clientInfo?.name,clientVersion:e?.clientInfo?.version},errorMessage:i.length>0?i.join(`; `):void 0,logs:i.length>0?i:void 0}}const D=ie;var se=class{constructor(){this.name=`initialize`,this.description=`Tests MCP client initialization handshake`,this.server=null,this.checks=[],this.port=0}async start(){return new Promise((e,t)=>{this.server=o.createServer((e,t)=>{this.handleRequest(e,t)}),this.server.on(`error`,t),this.server.listen(0,()=>{let n=this.server.address();n&&typeof n==`object`?(this.port=n.port,e({serverUrl:`http://localhost:${this.port}`})):t(Error(`Failed to get server address`))})})}async stop(){return new Promise((e,t)=>{this.server?this.server.close(n=>{n?t(n):(this.server=null,e())}):e()})}getChecks(){return this.checks}handleRequest(e,t){let n=``;e.on(`data`,e=>{n+=e.toString()}),e.on(`end`,()=>{try{let e=JSON.parse(n);e.method===`initialize`?this.handleInitialize(e,t):e.method===`tools/list`?this.handleToolsList(e,t):(t.writeHead(200,{"Content-Type":`application/json`}),t.end(JSON.stringify({jsonrpc:`2.0`,id:e.id,result:{}})))}catch(e){t.writeHead(400,{"Content-Type":`application/json`}),t.end(JSON.stringify({jsonrpc:`2.0`,error:{code:-32700,message:`Parse error ${e}`}}))}})}handleInitialize(e,t){let n=e.params,r=D.createClientInitializationCheck(n);this.checks.push(r);let i={name:`test-server`,version:`1.0.0`};this.checks.push(D.createServerInfoCheck(i));let a=[`2025-06-18`,`2025-11-25`],o=n?.protocolVersion,s=a.includes(o)?o:`2025-11-25`,c={jsonrpc:`2.0`,id:e.id,result:{protocolVersion:s,serverInfo:i,capabilities:{}}};t.writeHead(200,{"Content-Type":`application/json`}),t.end(JSON.stringify(c))}handleToolsList(e,t){let n={jsonrpc:`2.0`,id:e.id,result:{tools:[]}};t.writeHead(200,{"Content-Type":`application/json`}),t.end(JSON.stringify(n))}};function O(e,t){return(n,r,i)=>{let a=`Received ${n.method} request for ${n.path}`,o={method:n.method,path:n.path,body:n.body};if(Object.keys(n.query).length>0&&(o.query=n.query),t.mcpRoute&&n.path===t.mcpRoute&&n.get(`content-type`)?.includes(`application/json`)&&n.body&&typeof n.body==`object`&&n.body.method){let e=n.body.method;a+=` (method: ${e})`,o.mcpMethod=e}e.push({id:t.incomingId,name:t.incomingId.charAt(0).toUpperCase()+t.incomingId.slice(1),description:a,status:`INFO`,timestamp:new Date().toISOString(),details:o});let s=r.write.bind(r),c=r.end.bind(r),l=[];r.write=function(e,...t){return l.push(e),s(e,...t)},r.end=function(i,...a){i&&l.push(i);let s=l.map(e=>typeof e==`string`?Buffer.from(e):e),u=Buffer.concat(s).toString(`utf8`),d=`Sent ${r.statusCode} response for ${n.method} ${n.path}`,f={method:n.method,path:n.path,statusCode:r.statusCode};o.mcpMethod&&(d+=` (method: ${o.mcpMethod})`,f.mcpMethod=o.mcpMethod);let p=r.getHeaders();if(Object.keys(p).length>0&&(f.headers=p),u)try{f.body=JSON.parse(u)}catch{f.body=u}return e.push({id:t.outgoingId,name:t.outgoingId.charAt(0).toUpperCase()+t.outgoingId.slice(1),description:d,status:`INFO`,timestamp:new Date().toISOString(),details:f}),c(i,...a)},i()}}function ce(e){let t=new s({name:`add-numbers-server`,version:`1.0.0`},{capabilities:{tools:{}}});t.setRequestHandler(h,async()=>({tools:[{name:`add_numbers`,description:`Add two numbers together`,inputSchema:{type:`object`,properties:{a:{type:`number`,description:`First number`},b:{type:`number`,description:`Second number`}},required:[`a`,`b`]}}]})),t.setRequestHandler(l,async t=>{if(t.params.name===`add_numbers`){let{a:n,b:r}=t.params.arguments,i=n+r;return e.push({id:`tool-add-numbers`,name:`ToolAddNumbers`,description:`Validates that the add_numbers tool works correctly`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[{id:`MCP-Tools`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}],details:{a:n,b:r,result:i}}),{content:[{type:`text`,text:`The sum of ${n} and ${r} is ${i}`}]}}throw Error(`Unknown tool: ${t.params.name}`)});let n=y();return n.use(y.json()),n.use(O(e,{incomingId:`incoming-request`,outgoingId:`outgoing-response`,mcpRoute:`/mcp`})),n.post(`/mcp`,async(e,n)=>{let r=new c({sessionIdGenerator:void 0});await t.connect(r),await r.handleRequest(e,n,e.body)}),n}var le=class{constructor(){this.name=`tools_call`,this.description=`Tests calling tools with various parameter types`,this.app=null,this.httpServer=null,this.checks=[]}async start(){return this.checks=[],this.app=ce(this.checks),this.httpServer=this.app.listen(0),{serverUrl:`http://localhost:${this.httpServer.address().port}/mcp`}}async stop(){this.httpServer&&=(await new Promise(e=>this.httpServer.close(e)),null),this.app=null}getChecks(){for(let e of[`tool-add-numbers`])this.checks.find(t=>t.id===e)||this.checks.push({id:e,name:`ToolAddNumbers`,description:`Validates that the add_numbers tool works correctly`,status:`FAILURE`,timestamp:new Date().toISOString(),details:{message:`Tool was not called by client`},specReferences:[{id:`MCP-Tools`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}]});return this.checks}};function ue(e){return!!(typeof e==`object`&&e&&`method`in e&&e.method===`initialize`)}function de(e){let t={},n={},r=()=>{let t=new s({name:`elicitation-defaults-test-server`,version:`1.0.0`},{capabilities:{tools:{}}});return t.setRequestHandler(h,async()=>({tools:[{name:`test_client_elicitation_defaults`,description:`Tests that client applies defaults for omitted elicitation fields`,inputSchema:{type:`object`,properties:{},required:[]}}]})),t.setRequestHandler(l,async n=>{if(n.params.name===`test_client_elicitation_defaults`)try{let n=await t.request({method:`elicitation/create`,params:{message:`Test client default value handling - please accept with defaults`,requestedSchema:{type:`object`,properties:{name:{type:`string`,description:`User name`,default:`John Doe`},age:{type:`integer`,description:`User age`,default:30},score:{type:`number`,description:`User score`,default:95.5},status:{type:`string`,description:`User status`,enum:[`active`,`inactive`,`pending`],default:`active`},verified:{type:`boolean`,description:`Verification status`,default:!0}},required:[]}}},p);if(n.action!==`accept`)return e.push({id:`client-elicitation-sep1034-general`,name:`ClientElicitationSEP1034General`,description:`Client accepts elicitation request`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Expected action 'accept', got '${n.action}'`,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}]}),{content:[{type:`text`,text:`Elicitation was not accepted`}]};let r=n.content||{},i=[];`name`in r?typeof r.name!=`string`&&i.push(`Expected string for "name", got ${typeof r.name}`):i.push(`Field "name" missing - should have default "John Doe"`),e.push({id:`client-elicitation-sep1034-string-default`,name:`ClientElicitationSEP1034StringDefault`,description:`Client applies string default value for elicitation`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`name`,expectedDefault:`John Doe`,receivedValue:r.name}});let a=[];`age`in r?typeof r.age!=`number`&&a.push(`Expected number for "age", got ${typeof r.age}`):a.push(`Field "age" missing - should have default 30`),e.push({id:`client-elicitation-sep1034-integer-default`,name:`ClientElicitationSEP1034IntegerDefault`,description:`Client applies integer default value for elicitation`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`age`,expectedDefault:30,receivedValue:r.age}});let o=[];`score`in r?typeof r.score!=`number`&&o.push(`Expected number for "score", got ${typeof r.score}`):o.push(`Field "score" missing - should have default 95.5`),e.push({id:`client-elicitation-sep1034-number-default`,name:`ClientElicitationSEP1034NumberDefault`,description:`Client applies number default value for elicitation`,status:o.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:o.length>0?o.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`score`,expectedDefault:95.5,receivedValue:r.score}});let s=[];`status`in r?typeof r.status==`string`?[`active`,`inactive`,`pending`].includes(r.status)||s.push(`Value "${r.status}" is not a valid enum member`):s.push(`Expected string for "status", got ${typeof r.status}`):s.push(`Field "status" missing - should have default "active"`),e.push({id:`client-elicitation-sep1034-enum-default`,name:`ClientElicitationSEP1034EnumDefault`,description:`Client applies enum default value for elicitation`,status:s.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:s.length>0?s.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`status`,expectedDefault:`active`,receivedValue:r.status}});let c=[];return`verified`in r?typeof r.verified!=`boolean`&&c.push(`Expected boolean for "verified", got ${typeof r.verified}`):c.push(`Field "verified" missing - should have default true`),e.push({id:`client-elicitation-sep1034-boolean-default`,name:`ClientElicitationSEP1034BooleanDefault`,description:`Client applies boolean default value for elicitation`,status:c.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:c.length>0?c.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`verified`,expectedDefault:!0,receivedValue:r.verified}}),{content:[{type:`text`,text:`Elicitation completed: ${JSON.stringify(r)}`}]}}catch(t){return e.push({id:`client-elicitation-sep1034-general`,name:`ClientElicitationSEP1034General`,description:`Client handles elicitation with defaults`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Elicitation failed: ${t.message}`,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}]}),{content:[{type:`text`,text:`Elicitation error: ${t.message}`}]}}throw Error(`Unknown tool: ${n.params.name}`)}),t},i=y();return i.use(y.json()),i.use(O(e,{incomingId:`incoming-request`,outgoingId:`outgoing-response`,mcpRoute:`/mcp`})),i.post(`/mcp`,async(e,i)=>{let a=e.headers[`mcp-session-id`];try{let o;if(a&&t[a])o=t[a];else if(!a&&ue(e.body)){let a=r();o=new c({sessionIdGenerator:()=>x(),onsessioninitialized:e=>{t[e]=o,n[e]=a}}),o.onclose=()=>{let e=o.sessionId;e&&t[e]&&(delete t[e],n[e]&&(n[e].close(),delete n[e]))},await a.connect(o),await o.handleRequest(e,i,e.body);return}else{i.status(400).json({jsonrpc:`2.0`,error:{code:-32e3,message:`Invalid or missing session ID`},id:null});return}await o.handleRequest(e,i,e.body)}catch{i.headersSent||i.status(500).json({jsonrpc:`2.0`,error:{code:-32603,message:`Internal server error`},id:null})}}),i.get(`/mcp`,async(e,n)=>{let r=e.headers[`mcp-session-id`];if(!r||!t[r]){n.status(400).send(`Invalid or missing session ID`);return}try{await t[r].handleRequest(e,n)}catch{n.headersSent||n.status(500).send(`Error establishing SSE stream`)}}),i.delete(`/mcp`,async(e,n)=>{let r=e.headers[`mcp-session-id`];if(!r||!t[r]){n.status(400).send(`Invalid or missing session ID`);return}try{await t[r].handleRequest(e,n)}catch{n.headersSent||n.status(500).send(`Error handling termination`)}}),{app:i,cleanup:()=>{for(let e of Object.keys(t))n[e]&&n[e].close()}}}var fe=class{constructor(){this.name=`elicitation-sep1034-client-defaults`,this.description=`Tests client applies default values for omitted elicitation fields (SEP-1034)`,this.app=null,this.httpServer=null,this.checks=[],this.cleanup=null}async start(){this.checks=[];let{app:e,cleanup:t}=de(this.checks);return this.app=e,this.cleanup=t,this.httpServer=this.app.listen(0),{serverUrl:`http://localhost:${this.httpServer.address().port}/mcp`}}async stop(){this.cleanup&&=(this.cleanup(),null),this.httpServer&&=(await new Promise(e=>this.httpServer.close(e)),null),this.app=null}getChecks(){for(let e of[`client-elicitation-sep1034-string-default`,`client-elicitation-sep1034-integer-default`,`client-elicitation-sep1034-number-default`,`client-elicitation-sep1034-enum-default`,`client-elicitation-sep1034-boolean-default`])this.checks.find(t=>t.id===e)||this.checks.push({id:e,name:e.replace(/-/g,``),description:`Server applies ${e.split(`-`)[4]} default for elicitation`,status:`FAILURE`,timestamp:new Date().toISOString(),details:{message:`Tool was not called by client`},specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}]});return this.checks}},pe=class{constructor(){this.name=`sse-retry`,this.description=`Tests that client respects SSE retry field timing and reconnects properly (SEP-1699)`,this.server=null,this.checks=[],this.port=0,this.toolStreamCloseTime=null,this.getReconnectionTime=null,this.getConnectionCount=0,this.lastEventIds=[],this.retryValue=500,this.eventIdCounter=0,this.sessionId=`session-${Date.now()}`,this.pendingToolCallId=null,this.getResponseStream=null,this.EARLY_TOLERANCE=50,this.LATE_TOLERANCE=200,this.VERY_LATE_MULTIPLIER=2}async start(){return new Promise((e,t)=>{this.server=o.createServer((e,t)=>{this.handleRequest(e,t)}),this.server.on(`error`,t),this.server.listen(0,()=>{let n=this.server.address();n&&typeof n==`object`?(this.port=n.port,e({serverUrl:`http://localhost:${this.port}`})):t(Error(`Failed to get server address`))})})}async stop(){return new Promise((e,t)=>{this.server?this.server.close(n=>{n?t(n):(this.server=null,e())}):e()})}getChecks(){return this.generateChecks(),this.checks}handleRequest(e,t){if(e.method===`GET`){this.getConnectionCount++,this.getReconnectionTime=performance.now();let n=e.headers[`last-event-id`],r=n?`Received GET request for ${e.url} (Last-Event-ID: ${n})`:`Received GET request for ${e.url}`;this.checks.push({id:`incoming-request`,name:`IncomingRequest`,description:r,status:`INFO`,timestamp:new Date().toISOString(),details:{method:`GET`,url:e.url,headers:e.headers,connectionCount:this.getConnectionCount}}),n&&this.lastEventIds.push(n),this.handleGetSSEStream(e,t)}else e.method===`POST`?this.handlePostRequest(e,t):(t.writeHead(405),t.end(`Method Not Allowed`))}handleGetSSEStream(e,t){t.writeHead(200,{"Content-Type":`text/event-stream`,"Cache-Control":`no-cache`,Connection:`keep-alive`,"mcp-session-id":this.sessionId}),this.eventIdCounter++;let n=`event-${this.eventIdCounter}`,r=`id: ${n}\nretry: ${this.retryValue}\ndata: \n\n`;if(t.write(r),this.checks.push({id:`outgoing-sse-event`,name:`OutgoingSseEvent`,description:`Sent SSE priming event on GET stream (id: ${n}, retry: ${this.retryValue}ms)`,status:`INFO`,timestamp:new Date().toISOString(),details:{eventId:n,retryMs:this.retryValue,eventType:`priming`,raw:r}}),this.getResponseStream=t,this.pendingToolCallId!==null){let e={jsonrpc:`2.0`,id:this.pendingToolCallId,result:{content:[{type:`text`,text:`Reconnection test completed successfully`}]}},n=`event-${++this.eventIdCounter}`,r=`event: message\nid: ${n}\ndata: ${JSON.stringify(e)}\n\n`;t.write(r),this.checks.push({id:`outgoing-sse-event`,name:`OutgoingSseEvent`,description:`Sent tool response on GET stream after reconnection (id: ${n})`,status:`INFO`,timestamp:new Date().toISOString(),details:{eventId:n,eventType:`message`,jsonrpcId:this.pendingToolCallId,body:e,raw:r}}),this.pendingToolCallId=null}}handlePostRequest(e,t){let n=``;e.on(`data`,e=>{n+=e.toString()}),e.on(`end`,()=>{try{let r=JSON.parse(n);this.checks.push({id:`incoming-request`,name:`IncomingRequest`,description:`Received POST request for ${e.url} (method: ${r.method})`,status:`INFO`,timestamp:new Date().toISOString(),details:{method:`POST`,url:e.url,jsonrpcMethod:r.method,jsonrpcId:r.id}}),r.method===`initialize`?this.handleInitialize(e,t,r):r.method===`tools/list`?this.handleToolsList(t,r):r.method===`tools/call`?this.handleToolsCall(t,r):r.id===void 0?(t.writeHead(202),t.end()):(t.writeHead(200,{"Content-Type":`application/json`,"mcp-session-id":this.sessionId}),t.end(JSON.stringify({jsonrpc:`2.0`,id:r.id,result:{}})))}catch(e){t.writeHead(400,{"Content-Type":`application/json`}),t.end(JSON.stringify({jsonrpc:`2.0`,error:{code:-32700,message:`Parse error: ${e}`}}))}})}handleInitialize(e,t,n){t.writeHead(200,{"Content-Type":`application/json`,"mcp-session-id":this.sessionId});let r={jsonrpc:`2.0`,id:n.id,result:{protocolVersion:`2025-03-26`,serverInfo:{name:`sse-retry-test-server`,version:`1.0.0`},capabilities:{tools:{}}}};t.end(JSON.stringify(r)),this.checks.push({id:`outgoing-response`,name:`OutgoingResponse`,description:`Sent initialize response`,status:`INFO`,timestamp:new Date().toISOString(),details:{jsonrpcId:n.id,body:r}})}handleToolsList(e,t){e.writeHead(200,{"Content-Type":`application/json`,"mcp-session-id":this.sessionId});let n={jsonrpc:`2.0`,id:t.id,result:{tools:[{name:`test_reconnection`,description:`A tool that triggers SSE stream closure to test client reconnection behavior`,inputSchema:{type:`object`,properties:{},required:[]}}]}};e.end(JSON.stringify(n)),this.checks.push({id:`outgoing-response`,name:`OutgoingResponse`,description:`Sent tools/list response`,status:`INFO`,timestamp:new Date().toISOString(),details:{jsonrpcId:t.id,body:n}})}handleToolsCall(e,t){this.pendingToolCallId=t.id,e.writeHead(200,{"Content-Type":`text/event-stream`,"Cache-Control":`no-cache`,Connection:`keep-alive`,"mcp-session-id":this.sessionId}),this.eventIdCounter++;let n=`event-${this.eventIdCounter}`,r=`id: ${n}\nretry: ${this.retryValue}\ndata: \n\n`;e.write(r),this.checks.push({id:`outgoing-sse-event`,name:`OutgoingSseEvent`,description:`Sent SSE priming event for tools/call (id: ${n}, retry: ${this.retryValue}ms)`,status:`INFO`,timestamp:new Date().toISOString(),details:{eventId:n,retryMs:this.retryValue,eventType:`priming`,raw:r}}),setTimeout(()=>{this.toolStreamCloseTime=performance.now(),this.checks.push({id:`outgoing-stream-close`,name:`OutgoingStreamClose`,description:`Closed tools/call SSE stream to trigger client reconnection`,status:`INFO`,timestamp:new Date().toISOString(),details:{retryMs:this.retryValue,pendingToolCallId:this.pendingToolCallId}}),e.end()},50)}generateChecks(){if(this.getConnectionCount<1){this.checks.push({id:`client-sse-graceful-reconnect`,name:`ClientGracefulReconnect`,description:`Client reconnects via GET after SSE stream is closed gracefully`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Client did not attempt GET reconnection after stream closure. Client should treat graceful stream close as reconnectable.`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{getConnectionCount:this.getConnectionCount,toolStreamCloseTime:this.toolStreamCloseTime,retryValue:this.retryValue}});return}if(this.checks.push({id:`client-sse-graceful-reconnect`,name:`ClientGracefulReconnect`,description:`Client reconnects via GET after SSE stream is closed gracefully`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{getConnectionCount:this.getConnectionCount}}),this.toolStreamCloseTime!==null&&this.getReconnectionTime!==null){let e=this.getReconnectionTime-this.toolStreamCloseTime,t=this.retryValue-this.EARLY_TOLERANCE,n=this.retryValue+this.LATE_TOLERANCE,r=e<t,i=e>n,a=e>this.retryValue*this.VERY_LATE_MULTIPLIER,o=!r&&!i,s=`SUCCESS`,c;r?(s=`FAILURE`,c=`Client reconnected too early (${e.toFixed(0)}ms instead of ${this.retryValue}ms). Client MUST respect the retry field and wait the specified time.`):a?(s=`FAILURE`,c=`Client reconnected very late (${e.toFixed(0)}ms instead of ${this.retryValue}ms). Client appears to be ignoring the retry field and using its own backoff strategy.`):i&&(s=`WARNING`,c=`Client reconnected slightly late (${e.toFixed(0)}ms instead of ${this.retryValue}ms). This is acceptable but may indicate network delays.`),this.checks.push({id:`client-sse-retry-timing`,name:`ClientRespectsRetryField`,description:`Client MUST respect the retry field, waiting the given number of milliseconds before attempting to reconnect`,status:s,timestamp:new Date().toISOString(),errorMessage:c,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{expectedRetryMs:this.retryValue,actualDelayMs:Math.round(e),minAcceptableMs:t,maxAcceptableMs:n,veryLateThresholdMs:this.retryValue*this.VERY_LATE_MULTIPLIER,earlyToleranceMs:this.EARLY_TOLERANCE,lateToleranceMs:this.LATE_TOLERANCE,withinTolerance:o,tooEarly:r,slightlyLate:i,veryLate:a,getConnectionCount:this.getConnectionCount}})}else this.checks.push({id:`client-sse-retry-timing`,name:`ClientRespectsRetryField`,description:`Client MUST respect the retry field timing`,status:`WARNING`,timestamp:new Date().toISOString(),errorMessage:`Could not measure timing - tool stream close time or GET reconnection time not recorded`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{toolStreamCloseTime:this.toolStreamCloseTime,getReconnectionTime:this.getReconnectionTime}});let e=this.lastEventIds.length>0&&this.lastEventIds[0]!==void 0;this.checks.push({id:`client-sse-last-event-id`,name:`ClientSendsLastEventId`,description:`Client SHOULD send Last-Event-ID header on reconnection for resumability`,status:e?`SUCCESS`:`WARNING`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{hasLastEventId:e,lastEventIds:this.lastEventIds,getConnectionCount:this.getConnectionCount},errorMessage:e?void 0:`Client did not send Last-Event-ID header on reconnection. This is a SHOULD requirement for resumability.`})}};async function k(e){let t=new S({name:`conformance-test-client`,version:`1.0.0`},{capabilities:{sampling:{},elicitation:{}}}),n=new C(new URL(e));return await t.connect(n),{client:t,close:async()=>{await t.close()}}}var me=class{constructor(e){this.loggingNotifications=[],this.progressNotifications=[],e.setNotificationHandler(g,e=>{this.loggingNotifications.push(e)}),e.setNotificationHandler(v,e=>{this.progressNotifications.push(e)})}getLoggingNotifications(){return this.loggingNotifications}getProgressNotifications(){return this.progressNotifications}getNotifications(){return this.loggingNotifications}},he=class{constructor(){this.name=`server-initialize`,this.description=`Test basic server initialization handshake.

**Server Implementation Requirements:**

**Endpoint**: \`initialize\`

**Requirements**:
- Accept \`initialize\` request with client info and capabilities
- Return valid initialize response with server info, protocol version, and capabilities
- Accept \`initialized\` notification from client after handshake

This test verifies the server can complete the two-phase initialization handshake successfully.`}async run(e){let t=[];try{let n=await k(e);t.push({id:`server-initialize`,name:`ServerInitialize`,description:`Server responds to initialize request with valid structure`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[{id:`MCP-Initialize`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle#initialization`}],details:{serverUrl:e,connected:!0}}),await n.close()}catch(e){t.push({id:`server-initialize`,name:`ServerInitialize`,description:`Server responds to initialize request with valid structure`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed to initialize: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Initialize`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle#initialization`}]})}return t}},ge=class{constructor(){this.name=`logging-set-level`,this.description="Test setting logging level.\n\n**Server Implementation Requirements:**\n\n**Endpoint**: `logging/setLevel`\n\n**Requirements**:\n- Accept log level setting\n- Filter subsequent log notifications based on level\n- Return empty object `{}`\n\n**Log Levels** (in order of severity):\n- `debug`\n- `info`\n- `notice`\n- `warning`\n- `error`\n- `critical`\n- `alert`\n- `emergency`"}async run(e){let t=[];try{let n=await k(e),r=await n.client.setLoggingLevel(`info`),i=[];r&&Object.keys(r).length>0&&i.push(`Expected empty object {} response`),t.push({id:`logging-set-level`,name:`LoggingSetLevel`,description:`Server accepts logging level setting`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Logging`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging`}],details:{result:r}}),await n.close()}catch(e){t.push({id:`logging-set-level`,name:`LoggingSetLevel`,description:`Server accepts logging level setting`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Logging`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging`}]})}return t}},_e=class{constructor(){this.name=`ping`,this.description=`Test ping utility for connection health check.

**Server Implementation Requirements:**

**Endpoint**: \`ping\`

**Requirements**:
- Accept ping request with no parameters
- Respond promptly with empty object \`{}\`

**Request Format**:

\`\`\`json
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
\`\`\`

**Response Format**:

\`\`\`json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
\`\`\`

**Implementation Note**: The ping utility allows either party to verify that their counterpart is still responsive and the connection is alive.`}async run(e){let t=[];try{let n=await k(e),r=await n.client.ping(),i=[];r&&Object.keys(r).length>0&&i.push(`Expected empty object {} response`),t.push({id:`ping`,name:`Ping`,description:`Server responds to ping requests`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Ping`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/ping`}],details:{result:r}}),await n.close()}catch(e){t.push({id:`ping`,name:`Ping`,description:`Server responds to ping requests`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Ping`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/ping`}]})}return t}},ve=class{constructor(){this.name=`completion-complete`,this.description=`Test completion endpoint.

**Server Implementation Requirements:**

**Endpoint**: \`completion/complete\`

**Requirements**:
- Accept completion requests for prompt or resource template arguments
- Provide contextual suggestions based on partial input
- Return array of completion values ranked by relevance

**Request Format**:

\`\`\`json
{
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "test_prompt_with_arguments"
    },
    "argument": {
      "name": "arg1",
      "value": "par"
    }
  }
}
\`\`\`

**Response Format**:

\`\`\`json
{
  "completion": {
    "values": ["paris", "park", "party"],
    "total": 150,
    "hasMore": false
  }
}
\`\`\`

**Implementation Note**: For conformance testing, completion support can be minimal or return empty arrays. The capability just needs to be declared and the endpoint must respond correctly.`}async run(e){let t=[];try{let n=await k(e),r=await n.client.complete({ref:{type:`ref/prompt`,name:`test_prompt_with_arguments`},argument:{name:`arg1`,value:`test`}}),i=[];r.completion?(r.completion.values||i.push(`Missing values array in completion`),Array.isArray(r.completion.values)||i.push(`completion.values is not an array`)):i.push(`Missing completion field`),t.push({id:`completion-complete`,name:`CompletionComplete`,description:`Server responds to completion requests`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Completion`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/completion`}],details:{result:r}}),await n.close()}catch(e){t.push({id:`completion-complete`,name:`CompletionComplete`,description:`Server responds to completion requests`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Completion`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/completion`}]})}return t}},ye=class{constructor(){this.name=`tools-list`,this.description=`Test listing available tools.

**Server Implementation Requirements:**

**Endpoint**: \`tools/list\`

**Requirements**:
- Return array of all available tools
- Each tool MUST have:
  - \`name\` (string)
  - \`description\` (string)
  - \`inputSchema\` (valid JSON Schema object)`}async run(e){let t=[];try{let n=await k(e),r=await n.client.listTools(),i=[];r.tools?(Array.isArray(r.tools)||i.push(`tools is not an array`),r.tools.forEach((e,t)=>{e.name||i.push(`Tool ${t}: missing name`),e.description||i.push(`Tool ${t}: missing description`),e.inputSchema||i.push(`Tool ${t}: missing inputSchema`)})):i.push(`Missing tools array`),t.push({id:`tools-list`,name:`ToolsList`,description:`Server lists available tools with valid structure`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Tools-List`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#listing-tools`}],details:{toolCount:r.tools?.length||0,tools:r.tools?.map(e=>e.name)}}),await n.close()}catch(e){t.push({id:`tools-list`,name:`ToolsList`,description:`Server lists available tools with valid structure`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Tools-List`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#listing-tools`}]})}return t}},be=class{constructor(){this.name=`tools-call-simple-text`,this.description=`Test calling a tool that returns simple text.

**Server Implementation Requirements:**

Implement tool \`test_simple_text\` with no arguments that returns:

\`\`\`json
{
  "content": [
    {
      "type": "text",
      "text": "This is a simple text response for testing."
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.callTool({name:`test_simple_text`}),i=[],a=r.content;a||i.push(`Missing content array`),Array.isArray(a)||i.push(`content is not an array`),a&&a.length===0&&i.push(`content array is empty`);let o=a&&a.find(e=>e.type===`text`);o||i.push(`No text content found`),o&&!o.text&&i.push(`Text content missing text field`),t.push({id:`tools-call-simple-text`,name:`ToolsCallSimpleText`,description:`Tool returns simple text content`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}],details:{result:r}}),await n.close()}catch(e){t.push({id:`tools-call-simple-text`,name:`ToolsCallSimpleText`,description:`Tool returns simple text content`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}]})}return t}},xe=class{constructor(){this.name=`tools-call-image`,this.description=`Test calling a tool that returns image content.

**Server Implementation Requirements:**

Implement tool \`test_image_content\` with no arguments that returns:

\`\`\`json
{
  "content": [
    {
      "type": "image",
      "data": "<base64-encoded-png>",
      "mimeType": "image/png"
    }
  ]
}
\`\`\`

**Implementation Note**: Use a minimal test image (e.g., 1x1 red pixel PNG)`}async run(e){let t=[];try{let n=await k(e),r=await n.client.callTool({name:`test_image_content`,arguments:{}}),i=[],a=r.content;a||i.push(`Missing content array`);let o=a&&a.find(e=>e.type===`image`);o||i.push(`No image content found`),o&&!o.data&&i.push(`Image content missing data field`),o&&!o.mimeType&&i.push(`Image content missing mimeType`),t.push({id:`tools-call-image`,name:`ToolsCallImage`,description:`Tool returns image content`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}],details:{mimeType:o?.mimeType,hasData:!!o?.data}}),await n.close()}catch(e){t.push({id:`tools-call-image`,name:`ToolsCallImage`,description:`Tool returns image content`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}]})}return t}},Se=class{constructor(){this.name=`tools-call-mixed-content`,this.description=`Test tool returning multiple content types.

**Server Implementation Requirements:**

Implement tool \`test_multiple_content_types\` with no arguments that returns:

\`\`\`json
{
  "content": [
    {
      "type": "text",
      "text": "Multiple content types test:"
    },
    {
      "type": "image",
      "data": "<base64>",
      "mimeType": "image/png"
    },
    {
      "type": "resource",
      "resource": {
        "uri": "test://mixed-content-resource",
        "mimeType": "application/json",
        "text": "{"test":"data","value":123}"
      }
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.callTool({name:`test_multiple_content_types`,arguments:{}}),i=[],a=r.content;a||i.push(`Missing content array`),a&&a.length<2&&i.push(`Expected multiple content items`);let o=a&&a.some(e=>e.type===`text`),s=a&&a.some(e=>e.type===`image`),c=a&&a.some(e=>e.type===`resource`);o||i.push(`Missing text content`),s||i.push(`Missing image content`),c||i.push(`Missing resource content`),t.push({id:`tools-call-mixed-content`,name:`ToolsCallMixedContent`,description:`Tool returns multiple content types`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}],details:{contentCount:a?a.length:0,contentTypes:a?a.map(e=>e.type):[]}}),await n.close()}catch(e){t.push({id:`tools-call-mixed-content`,name:`ToolsCallMixedContent`,description:`Tool returns multiple content types`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}]})}return t}},Ce=class{constructor(){this.name=`tools-call-with-logging`,this.description=`Test tool that sends log messages during execution.

**Server Implementation Requirements:**

Implement tool \`test_tool_with_logging\` with no arguments.

**Behavior**: During execution, send 3 log notifications at info level:
1. "Tool execution started"
2. "Tool processing data" (after ~50ms delay)
3. "Tool execution completed" (after another ~50ms delay)

**Returns**: Text content confirming execution

**Implementation Note**: The delays are important to test that clients can receive multiple log notifications during tool execution`}async run(e){let t=[];try{let n=await k(e),r=new me(n.client);await n.client.setLoggingLevel(`debug`),await n.client.callTool({name:`test_tool_with_logging`,arguments:{}}),await new Promise(e=>setTimeout(e,200));let i=r.getNotifications(),a=[];i.length===0?a.push(`No log notifications received`):i.length<3&&a.push(`Expected at least 3 log messages, got ${i.length}`),t.push({id:`tools-call-with-logging`,name:`ToolsCallWithLogging`,description:`Tool sends log messages during execution`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`MCP-Logging`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging`}],details:{logCount:i.length,logs:i.map(e=>e.params)}}),await n.close()}catch(e){t.push({id:`tools-call-with-logging`,name:`ToolsCallWithLogging`,description:`Tool sends log messages during execution`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Logging`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging`}]})}return t}},we=class{constructor(){this.name=`tools-call-error`,this.description=`Test tool error reporting.

**Server Implementation Requirements:**

Implement tool \`test_error_handling\` with no arguments.

**Behavior**: Always throw an error

**Returns**: JSON-RPC response with \`isError: true\`

\`\`\`json
{
  "isError": true,
  "content": [
    {
      "type": "text",
      "text": "This tool intentionally returns an error for testing"
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.callTool({name:`test_error_handling`,arguments:{}}),i=r.isError===!0,a=r.content&&r.content.length>0&&r.content[0].text;t.push({id:`tools-call-error`,name:`ToolsCallError`,description:`Tool returns error correctly`,status:i&&a?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i?a?void 0:`Error result missing error message`:`Tool did not return isError: true`,specReferences:[{id:`MCP-Error-Handling`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle`}],details:{result:r}}),await n.close()}catch(e){t.push({id:`tools-call-error`,name:`ToolsCallError`,description:`Tool returns error correctly`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Error-Handling`,url:`https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle`}]})}return t}},Te=class{constructor(){this.name=`tools-call-with-progress`,this.description=`Test tool that reports progress notifications.

**Server Implementation Requirements:**

Implement tool \`test_tool_with_progress\` with no arguments.

**Behavior**: If \`_meta.progressToken\` is provided in request:
- Send progress notification: \`0/100\`
- Wait ~50ms
- Send progress notification: \`50/100\`
- Wait ~50ms
- Send progress notification: \`100/100\`

If no progress token provided, just execute with delays.

**Returns**: Text content confirming execution

**Progress Notification Format**:

\`\`\`json
{
  "method": "notifications/progress",
  "params": {
    "progressToken": "<from request._meta.progressToken>",
    "progress": 50,
    "total": 100
  }
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=[],i=await n.client.request({method:`tools/call`,params:{name:`test_tool_with_progress`,arguments:{},_meta:{progressToken:`progress-test-1`}}},u,{onprogress:e=>{r.push(e)}}),a=[];if(r.length===0?a.push(`No progress notifications received`):r.length<3&&a.push(`Expected at least 3 progress notifications, got ${r.length}`),r.length>=3){let e=r[0].progress,t=r[1].progress,n=r[2].progress;e<=t&&t<=n||a.push(`Progress values should be increasing`)}t.push({id:`tools-call-with-progress`,name:`ToolsCallWithProgress`,description:`Tool reports progress notifications`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`MCP-Progress`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/progress`}],details:{progressCount:r.length,progressNotifications:r.map(e=>e),result:i}}),await n.close()}catch(e){t.push({id:`tools-call-with-progress`,name:`ToolsCallWithProgress`,description:`Tool reports progress notifications`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Progress`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/progress`}]})}return t}},Ee=class{constructor(){this.name=`tools-call-sampling`,this.description=`Test tool that requests LLM sampling from client.

**Server Implementation Requirements:**

Implement tool \`test_sampling\` with argument:
- \`prompt\` (string, required) - The prompt to send to the LLM

**Behavior**: Request LLM sampling from the client using \`sampling/createMessage\`

**Sampling Request**:

\`\`\`json
{
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "<prompt from arguments>"
        }
      }
    ],
    "maxTokens": 100
  }
}
\`\`\`

**Returns**: Text content with the LLM's response

\`\`\`json
{
  "content": [
    {
      "type": "text",
      "text": "LLM response: <response from sampling>"
    }
  ]
}
\`\`\`

**Implementation Note**: If the client doesn't support sampling (no \`sampling\` capability), return an error.`}async run(e){let t=[];try{let n=await k(e),r=!1;n.client.setRequestHandler(d,async e=>(r=!0,{role:`assistant`,content:{type:`text`,text:`This is a test response from the client`},model:`test-model`,stopReason:`endTurn`}));let i=await n.client.callTool({name:`test_sampling`,arguments:{prompt:`Test prompt for sampling`}}),a=[];r||a.push(`Server did not request sampling from client`);let o=i.content;(!o||o.length===0)&&a.push(`Tool did not return content`),t.push({id:`tools-call-sampling`,name:`ToolsCallSampling`,description:`Tool requests LLM sampling from client`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`MCP-Sampling`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/sampling`}],details:{samplingRequested:r,result:i}}),await n.close()}catch(e){t.push({id:`tools-call-sampling`,name:`ToolsCallSampling`,description:`Tool requests LLM sampling from client`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Sampling`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/sampling`}]})}return t}},De=class{constructor(){this.name=`tools-call-elicitation`,this.description=`Test tool that requests user input (elicitation) from client.

**Server Implementation Requirements:**

Implement tool \`test_elicitation\` with argument:
- \`message\` (string, required) - The message to show the user

**Behavior**: Request user input from the client using \`elicitation/create\`

**Elicitation Request**:

\`\`\`json
{
  "method": "elicitation/create",
  "params": {
    "message": "<message from arguments>",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "User's response"
        },
        "email": {
          "type": "string",
          "description": "User's email address"
        }
      },
      "required": ["username", "email"]
    }
  }
}
\`\`\`

**Returns**: Text content with the user's response

\`\`\`json
{
  "content": [
    {
      "type": "text",
      "text": "User response: <action: accept/decline/cancel, content: {...}>"
    }
  ]
}
\`\`\`

**Implementation Note**: If the client doesn't support elicitation (no \`elicitation\` capability), return an error.`}async run(e){let t=[];try{let n=await k(e),r=!1;n.client.setRequestHandler(f,async e=>(r=!0,{action:`accept`,content:{username:`testuser`,email:`test@example.com`}}));let i=await n.client.callTool({name:`test_elicitation`,arguments:{message:`Please provide your information`}}),a=[];r||a.push(`Server did not request elicitation from client`);let o=i.content;(!o||o.length===0)&&a.push(`Tool did not return content`),t.push({id:`tools-call-elicitation`,name:`ToolsCallElicitation`,description:`Tool requests user input from client`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`MCP-Elicitation`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/elicitation`}],details:{elicitationRequested:r,result:i}}),await n.close()}catch(e){t.push({id:`tools-call-elicitation`,name:`ToolsCallElicitation`,description:`Tool requests user input from client`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Elicitation`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/elicitation`}]})}return t}},Oe=class{constructor(){this.name=`tools-call-audio`,this.description=`Test calling a tool that returns audio content.

**Server Implementation Requirements:**

Implement tool \`test_audio_content\` with no arguments that returns:

\`\`\`json
{
  "content": [
    {
      "type": "audio",
      "data": "<base64-encoded-wav>",
      "mimeType": "audio/wav"
    }
  ]
}
\`\`\`

**Implementation Note**: Use a minimal test audio file`}async run(e){let t=[];try{let n=await k(e),r=await n.client.callTool({name:`test_audio_content`,arguments:{}}),i=[],a=r.content;a||i.push(`Missing content array`),Array.isArray(a)||i.push(`content is not an array`),a&&a.length===0&&i.push(`content array is empty`);let o=a&&a.find(e=>e.type===`audio`);o||i.push(`No audio content found`),o&&!o.data&&i.push(`Audio content missing data field`),o&&!o.mimeType&&i.push(`Audio content missing mimeType field`),o&&o.mimeType!==`audio/wav`&&i.push(`Expected mimeType 'audio/wav', got '${o.mimeType}'`),t.push({id:`tools-call-audio`,name:`ToolsCallAudio`,description:`Tool returns audio content`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}],details:{hasAudioContent:!!o,audioDataLength:o?.data?.length||0}}),await n.close()}catch(e){t.push({id:`tools-call-audio`,name:`ToolsCallAudio`,description:`Tool returns audio content`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}]})}return t}},ke=class{constructor(){this.name=`tools-call-embedded-resource`,this.description=`Test calling a tool that returns embedded resource content.

**Server Implementation Requirements:**

Implement tool \`test_embedded_resource\` with no arguments that returns:

\`\`\`json
{
  "content": [
    {
      "type": "resource",
      "resource": {
        "uri": "test://embedded-resource",
        "mimeType": "text/plain",
        "text": "This is an embedded resource content."
      }
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.callTool({name:`test_embedded_resource`,arguments:{}}),i=[],a=r.content;a||i.push(`Missing content array`),Array.isArray(a)||i.push(`content is not an array`),a&&a.length===0&&i.push(`content array is empty`);let o=a&&a.find(e=>e.type===`resource`);o||i.push(`No resource content found`),o&&!o.resource&&i.push(`Resource content missing resource field`),o?.resource&&(o.resource.uri||i.push(`Resource missing uri field`),o.resource.mimeType||i.push(`Resource missing mimeType field`),!o.resource.text&&!o.resource.blob&&i.push(`Resource missing both text and blob fields`)),t.push({id:`tools-call-embedded-resource`,name:`ToolsCallEmbeddedResource`,description:`Tool returns embedded resource content`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}],details:{hasResourceContent:!!o,resourceUri:o?.resource?.uri}}),await n.close()}catch(e){t.push({id:`tools-call-embedded-resource`,name:`ToolsCallEmbeddedResource`,description:`Tool returns embedded resource content`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Tools-Call`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools`}]})}return t}};const A=`json_schema_2020_12_tool`,j=`https://json-schema.org/draft/2020-12/schema`;var Ae=class{constructor(){this.name=`json-schema-2020-12`,this.description=`Validates JSON Schema 2020-12 keyword preservation (SEP-1613).

**Server Implementation Requirements:**

Implement tool \`${A}\` with inputSchema containing JSON Schema 2020-12 features:

\`\`\`json
{
  "name": "${A}",
  "description": "Tool with JSON Schema 2020-12 features",
  "inputSchema": {
    "$schema": "${j}",
    "type": "object",
    "$defs": {
      "address": {
        "type": "object",
        "properties": {
          "street": { "type": "string" },
          "city": { "type": "string" }
        }
      }
    },
    "properties": {
      "name": { "type": "string" },
      "address": { "$ref": "#/$defs/address" }
    },
    "additionalProperties": false
  }
}
\`\`\`

**Verification**: The test verifies that \`$schema\`, \`$defs\`, and \`additionalProperties\` are preserved in the tool listing response.`}async run(e){let t=[],n=[{id:`SEP-1613`,url:`https://github.com/modelcontextprotocol/specification/pull/655`}];try{let r=await k(e),i=await r.client.listTools(),a=i.tools?.find(e=>e.name===A);if(t.push({id:`json-schema-2020-12-tool-found`,name:`JsonSchema2020_12ToolFound`,description:`Server advertises tool '${A}'`,status:a?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a?void 0:`Tool '${A}' not found. Available tools: ${i.tools?.map(e=>e.name).join(`, `)||`none`}`,specReferences:n,details:{toolFound:!!a,availableTools:i.tools?.map(e=>e.name)||[]}}),!a)return await r.close(),t;let o=a.inputSchema,s=`$schema`in o,c=o.$schema,l=c===j;t.push({id:`json-schema-2020-12-$schema`,name:`JsonSchema2020_12$Schema`,description:`inputSchema.$schema field preserved with value '${j}'`,status:s&&l?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:s?l?void 0:`$schema has unexpected value: ${JSON.stringify(c)}`:`$schema field missing from inputSchema - field was likely stripped`,specReferences:n,details:{hasSchema:s,schemaValue:c,expected:j}});let u=`$defs`in o,d=o.$defs,f=d&&`address`in d;t.push({id:`json-schema-2020-12-$defs`,name:`JsonSchema2020_12$Defs`,description:`inputSchema.$defs field preserved with expected structure`,status:u&&f?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:u?f?void 0:`$defs exists but missing expected "address" definition`:`$defs field missing from inputSchema - field was likely stripped`,specReferences:n,details:{hasDefs:u,defsKeys:d?Object.keys(d):[],defsValue:d}});let p=`additionalProperties`in o,m=o.additionalProperties,h=m===!1;t.push({id:`json-schema-2020-12-additionalProperties`,name:`JsonSchema2020_12AdditionalProperties`,description:`inputSchema.additionalProperties field preserved`,status:p&&h?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:p?h?void 0:`additionalProperties has unexpected value: ${JSON.stringify(m)}, expected: false`:`additionalProperties field missing from inputSchema - field was likely stripped`,specReferences:n,details:{hasAdditionalProps:p,additionalPropsValue:m,expected:!1}}),await r.close()}catch(e){t.push({id:`json-schema-2020-12-error`,name:`JsonSchema2020_12Error`,description:`JSON Schema 2020-12 conformance test`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:n})}return t}},je=class{constructor(){this.name=`elicitation-sep1034-defaults`,this.description=`Test elicitation with default values for all primitive types (SEP-1034).

**Server Implementation Requirements:**

Implement a tool named \`test_elicitation_sep1034_defaults\` (no arguments) that requests \`elicitation/create\` from the client with a schema containing default values for all primitive types:
- \`name\` (string): default "John Doe"
- \`age\` (integer): default 30
- \`score\` (number): default 95.5
- \`status\` (string enum: ["active", "inactive", "pending"]): default "active"
- \`verified\` (boolean): default true

**Returns**: Text content with the elicitation result

\`\`\`json
{
  "content": [
    {
      "type": "text",
      "text": "Elicitation completed: action=<accept/decline/cancel>, content={...}"
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=null;if(n.client.setRequestHandler(f,async e=>(r=e,{action:`accept`,content:{name:`Jane Smith`,age:25,score:88,status:`inactive`,verified:!1}})),await n.client.callTool({name:`test_elicitation_sep1034_defaults`,arguments:{}}),!r)return t.push({id:`elicitation-sep1034-general`,name:`ElicitationSEP1034General`,description:`Server requests elicitation with default values`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Server did not request elicitation from client`,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}]}),await n.close(),t;let i=r.params?.requestedSchema?.properties,a=[];i?.name?(i.name.type!==`string`&&a.push(`Expected type "string", got "${i.name.type}"`),`default`in i.name?i.name.default!==`John Doe`&&a.push(`Expected default "John Doe", got "${i.name.default}"`):a.push(`Missing default field`)):a.push(`Missing string field "name"`),t.push({id:`elicitation-sep1034-string-default`,name:`ElicitationSEP1034StringDefault`,description:`String schema includes default value`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`name`,schema:i?.name}});let o=[];i?.age?(i.age.type!==`integer`&&o.push(`Expected type "integer", got "${i.age.type}"`),`default`in i.age?i.age.default!==30&&o.push(`Expected default 30, got ${i.age.default}`):o.push(`Missing default field`)):o.push(`Missing integer field "age"`),t.push({id:`elicitation-sep1034-integer-default`,name:`ElicitationSEP1034IntegerDefault`,description:`Integer schema includes default value`,status:o.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:o.length>0?o.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`age`,schema:i?.age}});let s=[];i?.score?(i.score.type!==`number`&&s.push(`Expected type "number", got "${i.score.type}"`),`default`in i.score?i.score.default!==95.5&&s.push(`Expected default 95.5, got ${i.score.default}`):s.push(`Missing default field`)):s.push(`Missing number field "score"`),t.push({id:`elicitation-sep1034-number-default`,name:`ElicitationSEP1034NumberDefault`,description:`Number schema includes default value`,status:s.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:s.length>0?s.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`score`,schema:i?.score}});let c=[];i?.status?(i.status.type!==`string`&&c.push(`Expected type "string", got "${i.status.type}"`),(!i.status.enum||!Array.isArray(i.status.enum))&&c.push(`Missing or invalid enum array`),`default`in i.status?(i.status.default!==`active`&&c.push(`Expected default "active", got "${i.status.default}"`),i.status.enum&&!i.status.enum.includes(i.status.default)&&c.push(`Default value "${i.status.default}" is not a valid enum member`)):c.push(`Missing default field`)):c.push(`Missing enum field "status"`),t.push({id:`elicitation-sep1034-enum-default`,name:`ElicitationSEP1034EnumDefault`,description:`Enum schema includes valid default value`,status:c.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:c.length>0?c.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`status`,schema:i?.status}});let l=[];i?.verified?(i.verified.type!==`boolean`&&l.push(`Expected type "boolean", got "${i.verified.type}"`),`default`in i.verified?i.verified.default!==!0&&l.push(`Expected default true, got ${i.verified.default}`):l.push(`Missing default field`)):l.push(`Missing boolean field "verified"`),t.push({id:`elicitation-sep1034-boolean-default`,name:`ElicitationSEP1034BooleanDefault`,description:`Boolean schema includes default value`,status:l.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:l.length>0?l.join(`; `):void 0,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}],details:{field:`verified`,schema:i?.verified}}),await n.close()}catch(e){t.push({id:`elicitation-sep1034-general`,name:`ElicitationSEP1034General`,description:`Server requests elicitation with default values`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`SEP-1034`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1034`}]})}return t}},Me=class{constructor(){this.name=`elicitation-sep1330-enums`,this.description=`Test elicitation with enum schema improvements (SEP-1330).

**Server Implementation Requirements:**

Implement a tool named \`test_elicitation_sep1330_enums\` (no arguments) that requests \`elicitation/create\` from the client with a schema containing all 5 enum variants:

1. **Untitled single-select**: \`{ type: "string", enum: ["option1", "option2", "option3"] }\`
2. **Titled single-select**: \`{ type: "string", oneOf: [{ const: "value1", title: "First Option" }, ...] }\`
3. **Legacy titled (deprecated)**: \`{ type: "string", enum: ["opt1", "opt2", "opt3"], enumNames: ["Option One", "Option Two", "Option Three"] }\`
4. **Untitled multi-select**: \`{ type: "array", items: { type: "string", enum: ["option1", "option2", "option3"] } }\`
5. **Titled multi-select**: \`{ type: "array", items: { anyOf: [{ const: "value1", title: "First Choice" }, ...] } }\`

**Returns**: Text content with the elicitation result

\`\`\`json
{
  "content": [
    {
      "type": "text",
      "text": "Elicitation completed: action=<accept/decline/cancel>, content={...}"
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=null;if(n.client.setRequestHandler(f,async e=>(r=e,{action:`accept`,content:{untitledSingle:`option1`,titledSingle:`value1`,legacyEnum:`opt1`,untitledMulti:[`option1`,`option2`],titledMulti:[`value1`,`value2`]}})),await n.client.callTool({name:`test_elicitation_sep1330_enums`,arguments:{}}),!r)return t.push({id:`elicitation-sep1330-general`,name:`ElicitationSEP1330General`,description:`Server requests elicitation with enum schemas`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Server did not request elicitation from client`,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}]}),await n.close(),t;let i=r.params?.requestedSchema?.properties,a=[];i?.untitledSingle?(i.untitledSingle.type!==`string`&&a.push(`Expected type "string", got "${i.untitledSingle.type}"`),(!i.untitledSingle.enum||!Array.isArray(i.untitledSingle.enum))&&a.push(`Missing or invalid enum array`),i.untitledSingle.oneOf&&a.push(`Untitled enum should not have oneOf property`),i.untitledSingle.enumNames&&a.push(`Untitled enum should not have enumNames property`)):a.push(`Missing untitled single-select enum field "untitledSingle"`),t.push({id:`elicitation-sep1330-untitled-single`,name:`ElicitationSEP1330UntitledSingle`,description:`Untitled single-select enum schema uses enum array`,status:a.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:a.length>0?a.join(`; `):void 0,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}],details:{field:`untitledSingle`,schema:i?.untitledSingle}});let o=[];i?.titledSingle?(i.titledSingle.type!==`string`&&o.push(`Expected type "string", got "${i.titledSingle.type}"`),!i.titledSingle.oneOf||!Array.isArray(i.titledSingle.oneOf)?o.push(`Missing or invalid oneOf array for titled enum`):i.titledSingle.oneOf.filter(e=>typeof e.const!=`string`||typeof e.title!=`string`).length>0&&o.push(`oneOf items must have "const" (string) and "title" (string) properties`),i.titledSingle.enum&&o.push(`Titled enum should use oneOf instead of enum array`)):o.push(`Missing titled single-select enum field "titledSingle"`),t.push({id:`elicitation-sep1330-titled-single`,name:`ElicitationSEP1330TitledSingle`,description:`Titled single-select enum schema uses oneOf with const/title`,status:o.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:o.length>0?o.join(`; `):void 0,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}],details:{field:`titledSingle`,schema:i?.titledSingle}});let s=[];i?.legacyEnum?(i.legacyEnum.type!==`string`&&s.push(`Expected type "string", got "${i.legacyEnum.type}"`),(!i.legacyEnum.enum||!Array.isArray(i.legacyEnum.enum))&&s.push(`Missing or invalid enum array`),!i.legacyEnum.enumNames||!Array.isArray(i.legacyEnum.enumNames)?s.push(`Missing or invalid enumNames array for legacy titled enum`):i.legacyEnum.enum&&i.legacyEnum.enumNames.length!==i.legacyEnum.enum.length&&s.push(`enumNames length (${i.legacyEnum.enumNames.length}) must match enum length (${i.legacyEnum.enum.length})`)):s.push(`Missing legacy titled enum field "legacyEnum"`),t.push({id:`elicitation-sep1330-legacy-enumnames`,name:`ElicitationSEP1330LegacyEnumNames`,description:`Legacy titled enum schema uses enumNames (deprecated)`,status:s.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:s.length>0?s.join(`; `):void 0,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}],details:{field:`legacyEnum`,schema:i?.legacyEnum}});let c=[];i?.untitledMulti?(i.untitledMulti.type!==`array`&&c.push(`Expected type "array", got "${i.untitledMulti.type}"`),i.untitledMulti.items?(i.untitledMulti.items.type!==`string`&&c.push(`Expected items.type "string", got "${i.untitledMulti.items.type}"`),(!i.untitledMulti.items.enum||!Array.isArray(i.untitledMulti.items.enum))&&c.push(`Missing or invalid items.enum array`),i.untitledMulti.items.anyOf&&c.push(`Untitled multi-select should use items.enum, not items.anyOf`)):c.push(`Missing items property for array type`)):c.push(`Missing untitled multi-select enum field "untitledMulti"`),t.push({id:`elicitation-sep1330-untitled-multi`,name:`ElicitationSEP1330UntitledMulti`,description:`Untitled multi-select enum schema uses array with items.enum`,status:c.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:c.length>0?c.join(`; `):void 0,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}],details:{field:`untitledMulti`,schema:i?.untitledMulti}});let l=[];i?.titledMulti?(i.titledMulti.type!==`array`&&l.push(`Expected type "array", got "${i.titledMulti.type}"`),i.titledMulti.items?(!i.titledMulti.items.anyOf||!Array.isArray(i.titledMulti.items.anyOf)?l.push(`Missing or invalid items.anyOf array for titled multi-select`):i.titledMulti.items.anyOf.filter(e=>typeof e.const!=`string`||typeof e.title!=`string`).length>0&&l.push(`items.anyOf entries must have "const" (string) and "title" (string) properties`),i.titledMulti.items.enum&&l.push(`Titled multi-select should use items.anyOf, not items.enum`)):l.push(`Missing items property for array type`)):l.push(`Missing titled multi-select enum field "titledMulti"`),t.push({id:`elicitation-sep1330-titled-multi`,name:`ElicitationSEP1330TitledMulti`,description:`Titled multi-select enum schema uses array with items.anyOf`,status:l.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:l.length>0?l.join(`; `):void 0,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}],details:{field:`titledMulti`,schema:i?.titledMulti}}),await n.close()}catch(e){t.push({id:`elicitation-sep1330-general`,name:`ElicitationSEP1330General`,description:`Server requests elicitation with enum schemas`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`SEP-1330`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1330`}]})}return t}};function Ne(e){return async(t,n)=>{let r=n.method||`GET`,i=`Sending ${r} request`;if(n.body)try{let e=JSON.parse(n.body);e.method&&(i=`Sending ${r} ${e.method}`)}catch{}e.push({id:`outgoing-request`,name:`OutgoingRequest`,description:i,status:`INFO`,timestamp:new Date().toISOString(),details:{method:r,url:t,headers:n.headers,body:n.body?JSON.parse(n.body):void 0}});let a=await fetch(t,n),o={};return a.headers.forEach((e,t)=>{o[t]=e}),e.push({id:`incoming-response`,name:`IncomingResponse`,description:`Received ${a.status} response for ${r}`,status:`INFO`,timestamp:new Date().toISOString(),details:{statusCode:a.status,headers:o}}),a}}var Pe=class{constructor(){this.name=`server-sse-polling`,this.description=`Test server SSE polling via test_reconnection tool that closes stream mid-call (SEP-1699)`}async run(e){let t=[],n,r,i;try{r=new S({name:`conformance-test-client`,version:`1.0.0`},{capabilities:{sampling:{},elicitation:{}}}),i=new C(new URL(e)),await r.connect(i),n=i.sessionId,n||t.push({id:`server-sse-polling-session`,name:`ServerSSEPollingSession`,description:`Server provides session ID for SSE polling tests`,status:`WARNING`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{message:`Server did not provide session ID - SSE polling tests may not work correctly`}});let a=Ne(t),o=await a(e,{method:`POST`,headers:{"Content-Type":`application/json`,Accept:`text/event-stream, application/json`,...n&&{"mcp-session-id":n},"mcp-protocol-version":`2025-03-26`},body:JSON.stringify({jsonrpc:`2.0`,id:1,method:`tools/call`,params:{name:`test_reconnection`,arguments:{}}})});if(!o.ok)return o.status===400||o.status===404?(t.push({id:`server-sse-test-reconnection-tool`,name:`ServerTestReconnectionTool`,description:`Server implements test_reconnection tool for SSE polling tests`,status:`WARNING`,timestamp:new Date().toISOString(),errorMessage:`Server does not implement test_reconnection tool (HTTP ${o.status}). This tool is recommended for testing SSE polling behavior.`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}]}),t):(t.push({id:`server-sse-post-request`,name:`ServerSSEPostRequest`,description:`Server accepts POST request with SSE stream response`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Server returned HTTP ${o.status}`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}]}),t);let s=o.headers.get(`content-type`);if(!s?.includes(`text/event-stream`))return t.push({id:`server-sse-content-type`,name:`ServerSSEContentType`,description:`Server returns text/event-stream for POST request`,status:`INFO`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{contentType:s,message:`Server returned JSON instead of SSE stream - priming event tests not applicable`}}),t;let c=!1,l=!1,u=!1,d=!1,f,p,m=0,h=!1;if(!o.body)return t.push({id:`server-sse-polling-stream`,name:`ServerSSEPollingStream`,description:`Server provides SSE response body`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Response body is null`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}]}),t;let g=o.body.pipeThrough(new TextDecoderStream).pipeThrough(new w({onRetry:e=>{d=!0,f=e}})).getReader(),_=setTimeout(()=>{g.cancel()},1e4);try{for(;;){let{value:e,done:n}=await g.read();if(n)break;if(m++,e.id){c=!0,p=e.id;let n=e.data===``||e.data===`{}`||e.data.trim()===``;n&&(l=!0,m===1&&(u=!0)),t.push({id:`incoming-sse-event`,name:`IncomingSseEvent`,description:n?`Received SSE priming event (id: ${e.id})`:`Received SSE event (id: ${e.id})`,status:`INFO`,timestamp:new Date().toISOString(),details:{eventId:e.id,eventType:e.event||`message`,isPriming:n,hasRetryField:d,retryValue:f,data:e.data}})}if(e.data)try{let n=JSON.parse(e.data);if(n.id===1&&n.result){h=!0;let r=n.result?.isError===!0;t.push({id:`incoming-sse-event`,name:`IncomingSseEvent`,description:`Received tool response on POST stream`,status:r?`FAILURE`:`INFO`,timestamp:new Date().toISOString(),details:{eventId:e.id,body:n},...r&&{errorMessage:`Tool call failed`}})}}catch{}}}finally{clearTimeout(_)}t.push({id:`stream-closed`,name:`StreamClosed`,description:`POST SSE stream closed after ${m} event(s)`,status:`INFO`,timestamp:new Date().toISOString(),details:{eventCount:m,lastEventId:p,receivedToolResponse:h}});let v=`SUCCESS`,y;if(l?u||(v=`WARNING`,y=`Priming event was not sent first. It should be sent immediately when the SSE stream is established.`):(v=`WARNING`,y=`Server did not send priming event with id and empty data on POST SSE stream. This is recommended for resumability.`),t.push({id:`server-sse-priming-event`,name:`ServerSendsPrimingEvent`,description:`Server SHOULD send priming event with id and empty data on POST SSE streams`,status:v,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{hasPrimingEvent:l,primingEventIsFirst:u,hasEventId:c,lastEventId:p,eventCount:m},errorMessage:y}),t.push({id:`server-sse-retry-field`,name:`ServerSendsRetryField`,description:`Server SHOULD send retry field to control client reconnection timing`,status:d?`SUCCESS`:`WARNING`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{hasRetryField:d,retryValue:f},errorMessage:d?void 0:`Server did not send retry field. This is recommended for controlling client reconnection timing.`}),!h&&p&&n){let r=await a(e,{method:`GET`,headers:{Accept:`text/event-stream`,"mcp-session-id":n,"mcp-protocol-version":`2025-03-26`,"last-event-id":p}});if(r.ok&&r.body){let e=r.body.pipeThrough(new TextDecoderStream).pipeThrough(new w).getReader(),n=setTimeout(()=>{e.cancel()},5e3);try{for(;;){let{value:n,done:r}=await e.read();if(r)break;if(t.push({id:`incoming-sse-event`,name:`IncomingSseEvent`,description:`Received SSE event on GET reconnection stream (id: ${n.id||`none`})`,status:`INFO`,timestamp:new Date().toISOString(),details:{eventId:n.id,eventType:n.event||`message`,data:n.data}}),n.data)try{let e=JSON.parse(n.data);if(e.id===1&&e.result){h=!0;break}}catch{}}}finally{clearTimeout(n)}t.push({id:`server-sse-disconnect-resume`,name:`ServerDisconnectResume`,description:`Server closes SSE stream mid-call and resumes after client reconnects with Last-Event-ID`,status:h?`SUCCESS`:`WARNING`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{lastEventIdUsed:p,receivedToolResponse:h,message:h?`Successfully received tool response after reconnection`:`Tool response not received after reconnection`},errorMessage:h?void 0:`Server did not send tool response after client reconnected with Last-Event-ID`})}else r.status===405?t.push({id:`server-sse-disconnect-resume`,name:`ServerDisconnectResume`,description:`Server supports GET reconnection with Last-Event-ID`,status:`INFO`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{statusCode:r.status,message:`Server does not support standalone GET SSE endpoint (405 Method Not Allowed)`}}):t.push({id:`server-sse-disconnect-resume`,name:`ServerDisconnectResume`,description:`Server supports GET reconnection with Last-Event-ID`,status:`WARNING`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{statusCode:r.status,lastEventIdUsed:p,message:`Server returned ${r.status} for GET request with Last-Event-ID`},errorMessage:`Server did not accept reconnection with Last-Event-ID (HTTP ${r.status})`})}else h?t.push({id:`server-sse-disconnect-resume`,name:`ServerDisconnectResume`,description:`Server closes SSE stream mid-call and resumes after reconnection`,status:`INFO`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{receivedToolResponse:!0,message:`Tool response received on initial POST stream - server did not disconnect mid-call. The test_reconnection tool should close the stream before sending the result.`}}):t.push({id:`server-sse-disconnect-resume`,name:`ServerDisconnectResume`,description:`Server closes SSE stream mid-call and resumes after reconnection`,status:`INFO`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{lastEventId:p,sessionId:n,message:`Could not test disconnect/resume - no last event ID or session ID available`}})}catch(e){t.push({id:`server-sse-polling-error`,name:`ServerSSEPollingTest`,description:`Test server SSE polling behavior`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Error: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}]})}finally{if(r)try{await r.close()}catch{}}return t}},Fe=class{constructor(){this.name=`server-sse-multiple-streams`,this.description=`Test server supports multiple concurrent POST SSE streams (SEP-1699)`}async run(e){let t=[],n,r,i;try{if(r=new S({name:`conformance-test-client`,version:`1.0.0`},{capabilities:{sampling:{},elicitation:{}}}),i=new C(new URL(e)),await r.connect(i),n=i.sessionId,!n)return t.push({id:`server-sse-multiple-streams-session`,name:`ServerSSEMultipleStreamsSession`,description:`Server provides session ID for multiple streams test`,status:`WARNING`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{message:`Server did not provide session ID - multiple streams test may not work correctly`}}),t;let a=[],o=[];for(let t=0;t<3;t++){let r=fetch(e,{method:`POST`,headers:{"Content-Type":`application/json`,Accept:`text/event-stream, application/json`,"mcp-session-id":n,"mcp-protocol-version":`2025-03-26`},body:JSON.stringify({jsonrpc:`2.0`,id:1e3+t,method:`tools/list`,params:{}})});o.push(r)}let s=await Promise.all(o);a.push(...s);let c=a.every(e=>e.ok),l=a.map(e=>e.status),u=a.map(e=>e.headers.get(`content-type`)),d=u.filter(e=>e?.includes(`text/event-stream`)).length;t.push({id:`server-accepts-multiple-post-streams`,name:`ServerAcceptsMultiplePostStreams`,description:`Server allows multiple concurrent POST requests (each may return SSE or JSON)`,status:c?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{numStreamsAttempted:3,numStreamsAccepted:l.filter(e=>e===200).length,numSseStreams:d,statuses:l,contentTypes:u},errorMessage:c?void 0:`Server rejected some requests. Statuses: ${l.join(`, `)}`});let f=await Promise.all(a.map(async(e,t)=>{if(!e.headers.get(`content-type`)?.includes(`text/event-stream`))return{index:t,type:`json`,skipped:!0};if(!e.ok||!e.body)return{index:t,type:`sse`,error:`Stream not available`};try{let n=e.body.pipeThrough(new TextDecoderStream).pipeThrough(new w).getReader(),r=new Promise(e=>setTimeout(()=>e(null),2e3)),i=n.read().then(({value:e})=>e),a=await Promise.race([i,r]);return await n.cancel(),{index:t,type:`sse`,event:a}}catch(e){return{index:t,type:`sse`,error:e instanceof Error?e.message:String(e)}}})),p=f.filter(e=>e.type===`sse`).filter(e=>!(`error`in e)).length;d>0?t.push({id:`server-sse-streams-functional`,name:`ServerSSEStreamsFunctional`,description:`Multiple POST SSE streams should be functional`,status:p===d?`SUCCESS`:p>0?`WARNING`:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{numSseStreams:d,functionalSseStreams:p,results:f},errorMessage:p<d?`Only ${p}/${d} SSE streams were functional`:void 0}):t.push({id:`server-sse-streams-functional`,name:`ServerSSEStreamsFunctional`,description:`Server returned JSON responses (SSE streams optional)`,status:`INFO`,timestamp:new Date().toISOString(),specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}],details:{numSseStreams:0,message:`Server returned JSON for all requests - SSE streaming is optional`,results:f}})}catch(e){t.push({id:`server-sse-multiple-streams-error`,name:`ServerSSEMultipleStreamsTest`,description:`Test server multiple SSE streams behavior`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Error: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`SEP-1699`,url:`https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1699`}]})}finally{if(r)try{await r.close()}catch{}}return t}},Ie=class{constructor(){this.name=`resources-list`,this.description=`Test listing available resources.

**Server Implementation Requirements:**

**Endpoint**: \`resources/list\`

**Requirements**:
- Return array of all available **direct resources** (not templates)
- Each resource MUST have:
  - \`uri\` (string)
  - \`name\` (string)
  - \`description\` (string)
  - \`mimeType\` (string, optional)`}async run(e){let t=[];try{let n=await k(e),r=await n.client.listResources(),i=[];r.resources?(Array.isArray(r.resources)||i.push(`resources is not an array`),r.resources.forEach((e,t)=>{e.uri||i.push(`Resource ${t}: missing uri`),e.name||i.push(`Resource ${t}: missing name`)})):i.push(`Missing resources array`),t.push({id:`resources-list`,name:`ResourcesList`,description:`Server lists available resources with valid structure`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Resources-List`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#listing-resources`}],details:{resourceCount:r.resources?.length||0,resources:r.resources?.map(e=>e.uri)}}),await n.close()}catch(e){t.push({id:`resources-list`,name:`ResourcesList`,description:`Server lists available resources with valid structure`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Resources-List`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#listing-resources`}]})}return t}},Le=class{constructor(){this.name=`resources-read-text`,this.description=`Test reading text resource.

**Server Implementation Requirements:**

Implement resource \`test://static-text\` that returns:

\`\`\`json
{
  "contents": [
    {
      "uri": "test://static-text",
      "mimeType": "text/plain",
      "text": "This is the content of the static text resource."
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.readResource({uri:`test://static-text`}),i=[];r.contents||i.push(`Missing contents array`),Array.isArray(r.contents)||i.push(`contents is not an array`),r.contents.length===0&&i.push(`contents array is empty`);let a=r.contents[0];a&&(a.uri||i.push(`Content missing uri`),a.mimeType||i.push(`Content missing mimeType`),a.text||i.push(`Content missing text field`)),t.push({id:`resources-read-text`,name:`ResourcesReadText`,description:`Read text resource successfully`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Resources-Read`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#reading-resources`}],details:{uri:a?.uri,mimeType:a?.mimeType,hasText:!!a?.text}}),await n.close()}catch(e){t.push({id:`resources-read-text`,name:`ResourcesReadText`,description:`Read text resource successfully`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Resources-Read`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#reading-resources`}]})}return t}},Re=class{constructor(){this.name=`resources-read-binary`,this.description=`Test reading binary resource.

**Server Implementation Requirements:**

Implement resource \`test://static-binary\` that returns:

\`\`\`json
{
  "contents": [
    {
      "uri": "test://static-binary",
      "mimeType": "image/png",
      "blob": "<base64-encoded-png>"
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.readResource({uri:`test://static-binary`}),i=[];r.contents||i.push(`Missing contents array`),r.contents.length===0&&i.push(`contents array is empty`);let a=r.contents[0];a&&(a.uri||i.push(`Content missing uri`),a.mimeType||i.push(`Content missing mimeType`),a.blob||i.push(`Content missing blob field`)),t.push({id:`resources-read-binary`,name:`ResourcesReadBinary`,description:`Read binary resource successfully`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Resources-Read`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#reading-resources`}],details:{uri:a?.uri,mimeType:a?.mimeType,hasBlob:!!a?.blob}}),await n.close()}catch(e){t.push({id:`resources-read-binary`,name:`ResourcesReadBinary`,description:`Read binary resource successfully`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Resources-Read`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#reading-resources`}]})}return t}},ze=class{constructor(){this.name=`resources-templates-read`,this.description=`Test reading resource from template.

**Server Implementation Requirements:**

Implement resource template \`test://template/{id}/data\` that substitutes parameters.

**Behavior**: When client requests \`test://template/123/data\`, substitute \`{id}\` with \`123\`

Returns (for \`uri: "test://template/123/data"\`):

\`\`\`json
{
  "contents": [
    {
      "uri": "test://template/123/data",
      "mimeType": "application/json",
      "text": "{"id":"123","templateTest":true,"data":"Data for ID: 123"}"
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.readResource({uri:`test://template/123/data`}),i=[];r.contents||i.push(`Missing contents array`),r.contents.length===0&&i.push(`contents array is empty`);let a=r.contents[0];if(a){a.uri||i.push(`Content missing uri`);let e=`text`in a,t=`blob`in a;!e&&!t&&i.push(`Content missing text or blob`);let n=e?a.text:t?`[binary]`:``;typeof n==`string`&&!n.includes(`123`)&&i.push(`Parameter substitution not reflected in content`)}t.push({id:`resources-templates-read`,name:`ResourcesTemplateRead`,description:`Read resource from template with parameter substitution`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Resources-Templates`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#resource-templates`}],details:{uri:a?.uri,content:a?`text`in a?a.text:a.blob:void 0}}),await n.close()}catch(e){t.push({id:`resources-templates-read`,name:`ResourcesTemplateRead`,description:`Read resource from template with parameter substitution`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Resources-Templates`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#resource-templates`}]})}return t}},Be=class{constructor(){this.name=`resources-subscribe`,this.description=`Test subscribing to resource updates.

**Server Implementation Requirements:**

**Endpoint**: \`resources/subscribe\`

**Requirements**:
- Accept subscription request with URI
- Track subscribed URIs
- Return empty object \`{}\`

Example request:

\`\`\`json
{
  "method": "resources/subscribe",
  "params": {
    "uri": "test://watched-resource"
  }
}
\`\`\``}async run(e){let t=[];try{let n=await k(e);await n.client.subscribeResource({uri:`test://watched-resource`}),t.push({id:`resources-subscribe`,name:`ResourcesSubscribe`,description:`Subscribe to resource successfully`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[{id:`MCP-Resources-Subscribe`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#resource-subscriptions`}]}),await n.close()}catch(e){t.push({id:`resources-subscribe`,name:`ResourcesSubscribe`,description:`Subscribe to resource successfully`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Resources-Subscribe`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#resource-subscriptions`}]})}return t}},Ve=class{constructor(){this.name=`resources-unsubscribe`,this.description=`Test unsubscribing from resource.

**Server Implementation Requirements:**

**Endpoint**: \`resources/unsubscribe\`

**Requirements**:
- Accept unsubscribe request with URI
- Remove URI from subscriptions
- Stop sending update notifications for that URI
- Return empty object \`{}\``}async run(e){let t=[];try{let n=await k(e);await n.client.subscribeResource({uri:`test://watched-resource`}),await n.client.unsubscribeResource({uri:`test://watched-resource`}),t.push({id:`resources-unsubscribe`,name:`ResourcesUnsubscribe`,description:`Unsubscribe from resource successfully`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[{id:`MCP-Resources-Subscribe`,url:`https://modelcontextprotocol.io/specification/2025-06-18/schema#unsubscriberequest`}]}),await n.close()}catch(e){t.push({id:`resources-unsubscribe`,name:`ResourcesUnsubscribe`,description:`Unsubscribe from resource successfully`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Resources-Subscribe`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/resources#resource-subscriptions`}]})}return t}},He=class{constructor(){this.name=`prompts-list`,this.description=`Test listing available prompts.

**Server Implementation Requirements:**

**Endpoint**: \`prompts/list\`

**Requirements**:
- Return array of all available prompts
- Each prompt MUST have:
  - \`name\` (string)
  - \`description\` (string)
  - \`arguments\` (array, optional) - list of required arguments`}async run(e){let t=[];try{let n=await k(e),r=await n.client.listPrompts(),i=[];r.prompts?(Array.isArray(r.prompts)||i.push(`prompts is not an array`),r.prompts.forEach((e,t)=>{e.name||i.push(`Prompt ${t}: missing name`),e.description||i.push(`Prompt ${t}: missing description`)})):i.push(`Missing prompts array`),t.push({id:`prompts-list`,name:`PromptsList`,description:`Server lists available prompts with valid structure`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Prompts-List`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#listing-prompts`}],details:{promptCount:r.prompts?.length||0,prompts:r.prompts?.map(e=>e.name)}}),await n.close()}catch(e){t.push({id:`prompts-list`,name:`PromptsList`,description:`Server lists available prompts with valid structure`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Prompts-List`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#listing-prompts`}]})}return t}},Ue=class{constructor(){this.name=`prompts-get-simple`,this.description=`Test getting a simple prompt without arguments.

**Server Implementation Requirements:**

Implement a prompt named \`test_simple_prompt\` with no arguments that returns:

\`\`\`json
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "This is a simple prompt for testing."
      }
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.getPrompt({name:`test_simple_prompt`}),i=[];r.messages||i.push(`Missing messages array`),Array.isArray(r.messages)||i.push(`messages is not an array`),r.messages.length===0&&i.push(`messages array is empty`),r.messages.forEach((e,t)=>{e.role||i.push(`Message ${t}: missing role`),e.content||i.push(`Message ${t}: missing content`)}),t.push({id:`prompts-get-simple`,name:`PromptsGetSimple`,description:`Get simple prompt successfully`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Prompts-Get`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#getting-prompts`}],details:{messageCount:r.messages?.length||0}}),await n.close()}catch(e){t.push({id:`prompts-get-simple`,name:`PromptsGetSimple`,description:`Get simple prompt successfully`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Prompts-Get`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#getting-prompts`}]})}return t}},We=class{constructor(){this.name=`prompts-get-with-args`,this.description=`Test parameterized prompt.

**Server Implementation Requirements:**

Implement a prompt named \`test_prompt_with_arguments\` with arguments:
- \`arg1\` (string, required) - First test argument
- \`arg2\` (string, required) - Second test argument

Returns (with args \`{arg1: "hello", arg2: "world"}\`):

\`\`\`json
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "Prompt with arguments: arg1='hello', arg2='world'"
      }
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.getPrompt({name:`test_prompt_with_arguments`,arguments:{arg1:`testValue1`,arg2:`testValue2`}}),i=[];r.messages||i.push(`Missing messages array`),r.messages.length===0&&i.push(`messages array is empty`);let a=JSON.stringify(r.messages);a.includes(`testValue1`)||i.push(`arg1 not substituted in prompt`),a.includes(`testValue2`)||i.push(`arg2 not substituted in prompt`),t.push({id:`prompts-get-with-args`,name:`PromptsGetWithArgs`,description:`Get parameterized prompt with argument substitution`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Prompts-Get`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#getting-prompts`}],details:{messageCount:r.messages?.length||0,messages:r.messages}}),await n.close()}catch(e){t.push({id:`prompts-get-with-args`,name:`PromptsGetWithArgs`,description:`Get parameterized prompt with argument substitution`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Prompts-Get`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#getting-prompts`}]})}return t}},Ge=class{constructor(){this.name=`prompts-get-embedded-resource`,this.description=`Test prompt with embedded resource content.

**Server Implementation Requirements:**

Implement a prompt named \`test_prompt_with_embedded_resource\` with argument:
- \`resourceUri\` (string, required) - URI of the resource to embed

Returns:

\`\`\`json
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "resource",
        "resource": {
          "uri": "<resourceUri from arguments>",
          "mimeType": "text/plain",
          "text": "Embedded resource content for testing."
        }
      }
    },
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "Please process the embedded resource above."
      }
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.getPrompt({name:`test_prompt_with_embedded_resource`,arguments:{resourceUri:`test://example-resource`}}),i=[];r.messages||i.push(`Missing messages array`),r.messages.some(e=>e.content?.type===`resource`||e.content?.resource!==void 0)||i.push(`No embedded resource found in prompt`),t.push({id:`prompts-get-embedded-resource`,name:`PromptsGetEmbeddedResource`,description:`Get prompt with embedded resource`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Prompts-Embedded-Resources`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#embedded-resources`}],details:{messageCount:r.messages?.length||0,messages:r.messages}}),await n.close()}catch(e){t.push({id:`prompts-get-embedded-resource`,name:`PromptsGetEmbeddedResource`,description:`Get prompt with embedded resource`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Prompts-Embedded-Resources`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#embedded-resources`}]})}return t}},Ke=class{constructor(){this.name=`prompts-get-with-image`,this.description=`Test prompt with image content.

**Server Implementation Requirements:**

Implement a prompt named \`test_prompt_with_image\` with no arguments that returns:

\`\`\`json
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "image",
        "data": "<base64-encoded-png>",
        "mimeType": "image/png"
      }
    },
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "Please analyze the image above."
      }
    }
  ]
}
\`\`\``}async run(e){let t=[];try{let n=await k(e),r=await n.client.getPrompt({name:`test_prompt_with_image`}),i=[];r.messages||i.push(`Missing messages array`),r.messages.some(e=>e.content?.type===`image`&&e.content?.data&&e.content?.mimeType)||i.push(`No image content found in prompt`),t.push({id:`prompts-get-with-image`,name:`PromptsGetWithImage`,description:`Get prompt with image content`,status:i.length===0?`SUCCESS`:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:i.length>0?i.join(`; `):void 0,specReferences:[{id:`MCP-Prompts-Image`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#image-content`}],details:{messageCount:r.messages?.length||0}}),await n.close()}catch(e){t.push({id:`prompts-get-with-image`,name:`PromptsGetWithImage`,description:`Get prompt with image content`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:`Failed: ${e instanceof Error?e.message:String(e)}`,specReferences:[{id:`MCP-Prompts-Image`,url:`https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#image-content`}]})}return t}};const qe=[{id:`MCP-DNS-Rebinding-Protection`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/security_best_practices#local-mcp-server-compromise`},{id:`MCP-Transport-Security`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/transports#security-warning`}];function Je(e){let t=new URL(e).hostname.toLowerCase();return t===`localhost`||t===`127.0.0.1`||t===`[::1]`||t===`::1`}function Ye(e){return new URL(e).host}async function Xe(e,t){let n=await ee(e,{method:`POST`,headers:{"Content-Type":`application/json`,Host:t,Origin:`http://${t}`,Accept:`application/json, text/event-stream`},body:JSON.stringify({jsonrpc:`2.0`,id:1,method:`initialize`,params:{protocolVersion:`2025-11-25`,capabilities:{},clientInfo:{name:`conformance-dns-rebinding-test`,version:`1.0.0`}}})}),r;try{r=await n.body.json()}catch{r=null}return{statusCode:n.statusCode,body:r}}var Ze=class{constructor(){this.name=`dns-rebinding-protection`,this.description=`Test DNS rebinding protection for localhost servers.

**Scope:** This test applies to localhost MCP servers running without HTTPS and without
authentication. These servers are vulnerable to DNS rebinding attacks where a malicious
website tricks a user's browser into making requests to the local server.

**Attack scenario:**
1. User visits malicious website (e.g., evil.com)
2. evil.com's DNS is configured to resolve to 127.0.0.1
3. Browser makes request to evil.com which actually goes to localhost
4. Without Host/Origin header validation, the local MCP server processes the request

**Requirements:**
- Server **MUST** validate the Host or Origin header on incoming requests
- Server **MUST** reject requests with non-localhost Host/Origin headers (HTTP 4xx)
- Server **MUST** accept requests with valid localhost Host/Origin headers

**Valid localhost values:** \`localhost\`, \`127.0.0.1\`, \`[::1]\` (with optional port)

**Note:** This test requires a localhost server URL. Non-localhost URLs will fail.

See: https://github.com/modelcontextprotocol/typescript-sdk/security/advisories/GHSA-w48q-cv73-mx4w`}async run(e){let t=[],n=new Date().toISOString(),r={id:`localhost-host-rebinding-rejected`,name:`DNSRebindingRejected`,description:`Server rejects requests with non-localhost Host/Origin headers`,timestamp:n,specReferences:qe},i={id:`localhost-host-valid-accepted`,name:`LocalhostHostAccepted`,description:`Server accepts requests with valid localhost Host/Origin headers`,timestamp:n,specReferences:qe};if(!Je(e)){let n=`DNS rebinding tests require a localhost server URL (localhost, 127.0.0.1, or [::1])`,a={serverUrl:e,reason:`non-localhost-url`};return t.push({...r,status:`FAILURE`,errorMessage:n,details:a}),t.push({...i,status:`FAILURE`,errorMessage:n,details:a}),t}let a=Ye(e),o=`evil.example.com`;try{let n=await Xe(e,o),i=n.statusCode>=400&&n.statusCode<500,a={hostHeader:o,originHeader:`http://${o}`,statusCode:n.statusCode,body:n.body};i?t.push({...r,status:`SUCCESS`,details:a}):t.push({...r,status:`FAILURE`,errorMessage:`Expected HTTP 4xx for invalid Host/Origin headers, got ${n.statusCode}`,details:a})}catch(e){t.push({...r,status:`FAILURE`,errorMessage:`Request failed: ${e instanceof Error?e.message:String(e)}`,details:{hostHeader:o,originHeader:`http://${o}`}})}try{let n=await Xe(e,a),r=n.statusCode>=200&&n.statusCode<300,o={hostHeader:a,originHeader:`http://${a}`,statusCode:n.statusCode,body:n.body};r?t.push({...i,status:`SUCCESS`,details:o}):t.push({...i,status:`FAILURE`,errorMessage:`Expected HTTP 2xx for valid localhost Host/Origin headers, got ${n.statusCode}`,details:o})}catch(e){t.push({...i,status:`FAILURE`,errorMessage:`Request failed: ${e instanceof Error?e.message:String(e)}`,details:{hostHeader:a,originHeader:`http://${a}`}})}return t}};const M={RFC_PRM_DISCOVERY:{id:`RFC-9728`,url:`https://www.rfc-editor.org/rfc/rfc9728.html#section-3.1`},RFC_AUTH_SERVER_METADATA_REQUEST:{id:`RFC-8414-metadata-request`,url:`https://www.rfc-editor.org/rfc/rfc8414.html#section-3.1`},LEGACY_2025_03_26_AUTH_DISCOVERY:{id:`MCP-2025-03-26-Authorization-metadata-discovery`,url:`https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization#server-metadata-discovery`},LEGACY_2025_03_26_AUTH_URL_FALLBACK:{id:`MCP-2025-03-26-Authorization-metadata-url-fallback`,url:`https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization#fallbacks-for-servers-without-metadata-discovery`},MCP_PRM_DISCOVERY:{id:`MCP-2025-06-18-PRM-discovery`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#protected-resource-metadata-discovery-requirements`},MCP_AUTH_DISCOVERY:{id:`MCP-Authorization-metadata-discovery`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#authorization-server-metadata-discovery`},MCP_DCR:{id:`MCP-Dynamic-client-registration`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/client#dynamic-client-registration`},OAUTH_2_1_AUTHORIZATION_ENDPOINT:{id:`OAUTH-2.1-authorization-endpoint`,url:`https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html#name-authorization-endpoint`},OAUTH_2_1_TOKEN:{id:`OAUTH-2.1-token-request`,url:`https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html#name-token-request`},MCP_ACCESS_TOKEN_USAGE:{id:`MCP-Access-token-usage`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#access-token-usage`},MCP_SCOPE_SELECTION_STRATEGY:{id:`MCP-Scope-selection-strategy`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#scope-selection-strategy`},MCP_SCOPE_CHALLENGE_HANDLING:{id:`MCP-Scope-challenge-handling`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#scope-challenge-handling`},MCP_AUTH_ERROR_HANDLING:{id:`MCP-Auth-error-handling`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#error-handling`},MCP_CLIENT_ID_METADATA_DOCUMENTS:{id:`MCP-Client-ID-Metadata-Documents`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#client-id-metadata-documents`},IETF_CIMD:{id:`IETF-OAuth-Client-ID-Metadata-Document`,url:`https://datatracker.ietf.org/doc/html/draft-ietf-oauth-client-id-metadata-document-00`},RFC_JWT_CLIENT_AUTH:{id:`RFC-7523-JWT-Client-Auth`,url:`https://datatracker.ietf.org/doc/html/rfc7523#section-2.2`},OAUTH_2_1_CLIENT_CREDENTIALS:{id:`OAUTH-2.1-client-credentials-grant`,url:`https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-13.html#section-4.2`},SEP_1046_CLIENT_CREDENTIALS:{id:`SEP-1046-Client-Credentials`,url:`https://github.com/modelcontextprotocol/ext-auth/blob/main/specification/draft/oauth-client-credentials.mdx`},RFC_8707_RESOURCE_INDICATORS:{id:`RFC-8707-Resource-Indicators`,url:`https://www.rfc-editor.org/rfc/rfc8707.html`},MCP_RESOURCE_PARAMETER:{id:`MCP-Resource-Parameter-Implementation`,url:`https://modelcontextprotocol.io/specification/draft/basic/authorization#resource-parameter-implementation`},MCP_PREREGISTRATION:{id:`MCP-Preregistration`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#preregistration`},MCP_PKCE:{id:`MCP-PKCE-requirement`,url:`https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization#authorization-code-protection`}};function Qe(e){return b(`sha256`).update(e).digest().toString(`base64`).replace(/\+/g,`-`).replace(/\//g,`_`).replace(/=+$/,``)}function N(e,t,n={}){let{metadataPath:r=`/.well-known/oauth-authorization-server`,isOpenIdConfiguration:i=!1,loggingEnabled:a=!0,routePrefix:o=``,scopesSupported:s,grantTypesSupported:c=[`authorization_code`,`refresh_token`],tokenEndpointAuthMethodsSupported:l=[`none`],tokenEndpointAuthSigningAlgValuesSupported:u,clientIdMetadataDocumentSupported:d,disableDynamicRegistration:f=!1,codeChallengeMethodsSupported:p=[`S256`],tokenVerifier:m,onTokenRequest:h,onAuthorizationRequest:g,onRegistrationRequest:_}=n,v=[],b,x={authorization_endpoint:`${o}/authorize`,token_endpoint:`${o}/token`,registration_endpoint:`${o}/register`},S=y();return S.use(y.json()),S.use(y.urlencoded({extended:!0})),a&&S.use(O(e,{incomingId:`incoming-auth-request`,outgoingId:`outgoing-auth-response`})),S.get(r,(n,r)=>{e.push({id:`authorization-server-metadata`,name:`AuthorizationServerMetadata`,description:`Client requested authorization server metadata`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.RFC_AUTH_SERVER_METADATA_REQUEST,M.MCP_AUTH_DISCOVERY],details:{url:n.url,path:n.path}});let a={issuer:t(),authorization_endpoint:`${t()}${x.authorization_endpoint}`,token_endpoint:`${t()}${x.token_endpoint}`,...!f&&{registration_endpoint:`${t()}${x.registration_endpoint}`},response_types_supported:[`code`],grant_types_supported:c,...p!==null&&{code_challenge_methods_supported:p},token_endpoint_auth_methods_supported:l,...u&&{token_endpoint_auth_signing_alg_values_supported:u}};s!==void 0&&(a.scopes_supported=s),d!==void 0&&(a.client_id_metadata_document_supported=d),i&&(a.jwks_uri=`${t()}/.well-known/jwks.json`,a.subject_types_supported=[`public`],a.id_token_signing_alg_values_supported=[`RS256`]),r.json(a)}),S.get(x.authorization_endpoint,(t,n)=>{let r=new Date().toISOString();e.push({id:`authorization-request`,name:`AuthorizationRequest`,description:`Client made authorization request`,status:`SUCCESS`,timestamp:r,specReferences:[M.OAUTH_2_1_AUTHORIZATION_ENDPOINT],details:{query:t.query}});let i=t.query.code_challenge,a=t.query.code_challenge_method;b=i,e.push({id:`pkce-code-challenge-sent`,name:`PKCE Code Challenge`,description:i?`Client sent code_challenge in authorization request`:`Client MUST send code_challenge in authorization request`,status:i?`SUCCESS`:`FAILURE`,timestamp:r,specReferences:[M.MCP_PKCE]}),e.push({id:`pkce-s256-method-used`,name:`PKCE S256 Method`,description:a===`S256`?`Client used S256 code challenge method`:`Client MUST use S256 code challenge method when technically capable`,status:a===`S256`?`SUCCESS`:`FAILURE`,timestamp:r,specReferences:[M.MCP_PKCE],details:{method:a||`not specified`}});let o=t.query.scope;v=o?o.split(` `):[],g&&g({clientId:t.query.client_id,scope:o,resource:t.query.resource,timestamp:r});let s=t.query.redirect_uri,c=t.query.state,l=new URL(s);l.searchParams.set(`code`,`test-auth-code`),c&&l.searchParams.set(`state`,c),n.redirect(l.toString())}),S.post(x.token_endpoint,async(n,r)=>{let i=new Date().toISOString(),a=n.body.scope,o=n.body.grant_type;e.push({id:`token-request`,name:`TokenRequest`,description:`Client requested access token`,status:`SUCCESS`,timestamp:i,specReferences:[M.OAUTH_2_1_TOKEN],details:{endpoint:`/token`,grantType:o}});let s=n.body.code_verifier;if(o===`authorization_code`){e.push({id:`pkce-code-verifier-sent`,name:`PKCE Code Verifier`,description:s?`Client sent code_verifier in token request`:`Client MUST send code_verifier in token request`,status:s?`SUCCESS`:`FAILURE`,timestamp:i,specReferences:[M.MCP_PKCE]});let t=s&&b?Qe(s):void 0,n=t!==void 0&&t===b,r;r=!b&&!s?`Neither code_challenge nor code_verifier were sent - PKCE is required`:b?s?n?`code_verifier correctly matches code_challenge (S256)`:`code_verifier does not match code_challenge`:`code_verifier was not sent in token request - PKCE is required`:`code_challenge was not sent in authorization request - PKCE is required`,e.push({id:`pkce-verifier-matches-challenge`,name:`PKCE Verifier Validation`,description:r,status:n?`SUCCESS`:`FAILURE`,timestamp:i,specReferences:[M.MCP_PKCE],details:{matches:n,storedChallenge:b||`not sent`,computedChallenge:t||`not computed`}})}let c=`test-token-${Date.now()}`,l=v;if(h){let e=await h({scope:a,grantType:o,timestamp:i,body:n.body,authBaseUrl:t(),tokenEndpoint:`${t()}${x.token_endpoint}`,authorizationHeader:n.headers.authorization});if(`error`in e){r.status(e.statusCode||400).json({error:e.error,error_description:e.errorDescription});return}c=e.token,l=e.scopes}m&&m.registerToken(c,l),r.json({access_token:c,token_type:`Bearer`,expires_in:3600,...l.length>0&&{scope:l.join(` `)}})}),S.post(x.registration_endpoint,(t,n)=>{let r=`test-client-id`,i=`test-client-secret`,a;if(_){let e=_(t);r=e.clientId,i=e.clientSecret,a=e.tokenEndpointAuthMethod}e.push({id:`client-registration`,name:`ClientRegistration`,description:`Client registered with authorization server`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.MCP_DCR],details:{endpoint:`/register`,clientName:t.body.client_name,...a&&{tokenEndpointAuthMethod:a}}}),n.status(201).json({client_id:r,...i&&{client_secret:i},client_name:t.body.client_name||`test-client`,redirect_uris:t.body.redirect_uris||[],...a&&{token_endpoint_auth_method:a}})}),S}var P=class{constructor(e,t=[]){this.checks=e,this.expectedScopes=t,this.tokenScopes=new Map}registerToken(e,t){this.tokenScopes.set(e,t)}async verifyAccessToken(e){if(e.startsWith(`test-token`)||e.startsWith(`cc-token`)){let t=this.tokenScopes.get(e)||[];return this.checks.push({id:`valid-bearer-token`,name:`ValidBearerToken`,description:`Client provided valid bearer token`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.MCP_ACCESS_TOKEN_USAGE],details:{token:e.substring(0,15)+`...`,scopes:t}}),{token:e,clientId:`test-client`,scopes:t,expiresAt:Math.floor(Date.now()/1e3)+3600}}throw this.checks.push({id:`invalid-bearer-token`,name:`InvalidBearerToken`,description:`Client provided invalid bearer token`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_ACCESS_TOKEN_USAGE],details:{message:`Token verification failed`,token:e?e.substring(0,10)+`...`:`missing`}}),Error(`Invalid token`)}};function F(e,t,n,r={}){let{prmPath:i=`/.well-known/oauth-protected-resource/mcp`,requiredScopes:a=[],scopesSupported:o,includePrmInWwwAuth:u=!0,includeScopeInWwwAuth:d=!1,tokenVerifier:f,prmResourceOverride:p}=r,g=new s({name:`auth-prm-pathbased-server`,version:`1.0.0`},{capabilities:{tools:{}}});g.setRequestHandler(h,async()=>({tools:[{name:`test-tool`,inputSchema:{type:`object`}}]})),g.setRequestHandler(l,async e=>{if(e.params.name===`test-tool`)return{content:[{type:`text`,text:`test`}]};throw new _(m.InvalidParams,`Tool ${e.params.name} not found`)});let v=y();return v.use(y.json()),v.use(O(e,{incomingId:`incoming-request`,outgoingId:`outgoing-response`,mcpRoute:`/mcp`})),i!==null&&v.get(i,(r,a)=>{e.push({id:`prm-pathbased-requested`,name:`PRMPathBasedRequested`,description:`Client requested PRM metadata at path-based location`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.RFC_PRM_DISCOVERY,M.MCP_PRM_DISCOVERY],details:{url:r.url,path:r.path}});let s={resource:p??(i===`/.well-known/oauth-protected-resource`?t():`${t()}/mcp`),authorization_servers:[n()]};o!==void 0&&(s.scopes_supported=o),a.json(s)}),v.post(`/mcp`,async(n,o,s)=>{let l=f||new P(e,a);(r.authMiddleware??te({verifier:l,requiredScopes:d?a:[],...u&&i!==null&&{resourceMetadataUrl:`${t()}${i}`}}))(n,o,async e=>{if(e)return s(e);let t=new c({sessionIdGenerator:void 0});try{await g.connect(t),await t.handleRequest(n,o,n.body),o.on(`close`,()=>{t.close(),g.close()})}catch(e){console.error(`Error handling MCP request:`,e),o.headersSent||o.status(500).json({jsonrpc:`2.0`,error:{code:-32603,message:`Internal server error`},id:null})}})}),v}var I=class{constructor(){this.app=null,this.httpServer=null,this.baseUrl=``,this.getUrl=()=>this.baseUrl}async start(e){return this.app=e,this.httpServer=this.app.listen(0),this.baseUrl=`http://localhost:${this.httpServer.address().port}`,this.baseUrl}async stop(){this.httpServer&&=(await new Promise(e=>{this.httpServer.closeAllConnections?.(),this.httpServer.close(()=>e())}),null),this.app=null}};const L=[{name:`metadata-default`,prmLocation:`/.well-known/oauth-protected-resource/mcp`,inWwwAuth:!0,oauthMetadataLocation:`/.well-known/oauth-authorization-server`,trapRootPrm:!0},{name:`metadata-var1`,prmLocation:`/.well-known/oauth-protected-resource/mcp`,inWwwAuth:!1,oauthMetadataLocation:`/.well-known/openid-configuration`},{name:`metadata-var2`,prmLocation:`/.well-known/oauth-protected-resource`,inWwwAuth:!1,oauthMetadataLocation:`/.well-known/oauth-authorization-server/tenant1`,authRoutePrefix:`/tenant1`},{name:`metadata-var3`,prmLocation:`/custom/metadata/location.json`,inWwwAuth:!0,oauthMetadataLocation:`/tenant1/.well-known/openid-configuration`,authRoutePrefix:`/tenant1`}];function R(e){let t=new I,n=new I,r=[],i=e.authRoutePrefix||``,a=e.oauthMetadataLocation.includes(`openid-configuration`),o=e.prmLocation===`/.well-known/oauth-protected-resource/mcp`;return{name:`auth/${e.name}`,description:`Tests Basic OAuth metadata discovery flow.

**PRM:** ${e.prmLocation}${e.inWwwAuth?``:` (not in WWW-Authenticate)`}
**OAuth metadata:** ${e.oauthMetadataLocation}
`,async start(){r=[];let o=N(r,t.getUrl,{metadataPath:e.oauthMetadataLocation,isOpenIdConfiguration:a,...i&&{routePrefix:i}});i&&o.get(`/.well-known/oauth-authorization-server`,(e,t)=>{r.push({id:`authorization-server-metadata-wrong-path`,name:`AuthorizationServerMetadataWrongPath`,description:`Client requested authorization server at the root path when the AS URL has a path-based location`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.RFC_AUTH_SERVER_METADATA_REQUEST,M.MCP_AUTH_DISCOVERY],details:{url:e.url}}),t.status(404).send(`Not Found`)}),await t.start(o);let s=i?()=>`${t.getUrl()}${i}`:t.getUrl,c=F(r,n.getUrl,s,{prmPath:e.prmLocation,includePrmInWwwAuth:e.inWwwAuth});return e.trapRootPrm&&c.get(`/.well-known/oauth-protected-resource`,(e,t)=>{r.push({id:`prm-priority-order`,name:`PRM Priority Order`,description:`Client requested PRM metadata at root location on a server with path-based PRM`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.RFC_PRM_DISCOVERY,M.MCP_PRM_DISCOVERY],details:{url:e.url,path:e.path}}),t.status(404).json({error:`not_found`,error_description:`PRM metadata not available at root location`})}),await n.start(c),{serverUrl:`${n.getUrl()}/mcp`}},async stop(){await t.stop(),await n.stop()},getChecks(){let e=[...o?[`prm-pathbased-requested`]:[],`authorization-server-metadata`,`client-registration`,`authorization-request`,`token-request`];for(let t of e)r.find(e=>e.id===t)||r.push({id:t,name:`Expected Check Missing: ${t}`,description:`Expected Check Missing: ${t}`,status:`FAILURE`,timestamp:new Date().toISOString()});return r}}}R(L[0]),R(L[1]),R(L[2]),R(L[3]);const $e=L.map(R);function et(){return $e.map(e=>e.name)}const tt=`https://conformance-test.local/client-metadata.json`;var nt=class{constructor(){this.name=`auth/basic-cimd`,this.description=`Tests OAuth flow with Client ID Metadata Documents (SEP-991/URL-based client IDs). Server advertises client_id_metadata_document_supported=true and client should use URL as client_id instead of DCR.`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=N(this.checks,this.authServer.getUrl,{clientIdMetadataDocumentSupported:!0,onAuthorizationRequest:e=>{let t=e.clientId===tt;this.checks.push({id:`cimd-client-id-used`,name:`Client ID Metadata Document Usage`,description:t?`Client correctly used URL-based client ID when server supports client_id_metadata_document_supported`:`Client SHOULD use URL-based client ID when server advertises client_id_metadata_document_supported=true`,status:t?`SUCCESS`:`WARNING`,timestamp:e.timestamp,specReferences:[M.MCP_CLIENT_ID_METADATA_DOCUMENTS,M.IETF_CIMD],details:{expectedClientId:tt,actualClientId:e.clientId||`none`}})}});await this.authServer.start(e);let t=F(this.checks,this.server.getUrl,this.authServer.getUrl);return await this.server.start(t),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`cimd-client-id-used`)||this.checks.push({id:`cimd-client-id-used`,name:`Client ID Metadata Document Usage`,description:`Client did not make an authorization request to test CIMD support`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_CLIENT_ID_METADATA_DOCUMENTS,M.IETF_CIMD]}),this.checks}},rt=class{constructor(){this.name=`auth/2025-03-26-oauth-metadata-backcompat`,this.description=`Tests 2025-03-26 spec OAuth flow: no PRM (Protected Resource Metadata), OAuth metadata at root location`,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=N(this.checks,this.server.getUrl,{loggingEnabled:!1,routePrefix:`/oauth`}),t=F(this.checks,this.server.getUrl,this.server.getUrl,{prmPath:null});return t.use(e),await this.server.start(t),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.server.stop()}getChecks(){for(let e of[`authorization-server-metadata`,`client-registration`,`authorization-request`,`token-request`])this.checks.find(t=>t.id===e)||this.checks.push({id:e,name:`Expected Check Missing: ${e}`,description:`Expected Check Missing: ${e}`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.LEGACY_2025_03_26_AUTH_DISCOVERY]});return this.checks}},it=class{constructor(){this.name=`auth/2025-03-26-oauth-endpoint-fallback`,this.description=`Tests OAuth flow with no metadata endpoints, relying on fallback to standard OAuth endpoints at server root (2025-03-26 spec behavior)`,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=F(this.checks,this.server.getUrl,this.server.getUrl,{prmPath:null});return e.use(y.urlencoded({extended:!0})),e.get(`/authorize`,(e,t)=>{this.checks.push({id:`authorization-request`,name:`AuthorizationRequest`,description:`Client made authorization request to fallback endpoint`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.LEGACY_2025_03_26_AUTH_URL_FALLBACK],details:{response_type:e.query.response_type,client_id:e.query.client_id,redirect_uri:e.query.redirect_uri,state:e.query.state,code_challenge:e.query.code_challenge?`present`:`missing`,code_challenge_method:e.query.code_challenge_method}});let n=e.query.redirect_uri,r=e.query.state,i=new URL(n);i.searchParams.set(`code`,`test-auth-code`),r&&i.searchParams.set(`state`,r),t.redirect(i.toString())}),e.post(`/token`,(e,t)=>{this.checks.push({id:`token-request`,name:`TokenRequest`,description:`Client requested access token from fallback endpoint`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.LEGACY_2025_03_26_AUTH_URL_FALLBACK],details:{endpoint:`/token`,grantType:e.body.grant_type}}),t.json({access_token:`test-token`,token_type:`Bearer`,expires_in:3600})}),e.post(`/register`,(e,t)=>{this.checks.push({id:`client-registration`,name:`ClientRegistration`,description:`Client registered with authorization server at fallback endpoint`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.LEGACY_2025_03_26_AUTH_URL_FALLBACK],details:{endpoint:`/register`,clientName:e.body.client_name}}),t.status(201).json({client_id:`test-client-id`,client_secret:`test-client-secret`,client_name:e.body.client_name||`test-client`,redirect_uris:e.body.redirect_uris||[]})}),await this.server.start(e),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.server.stop()}getChecks(){for(let e of[`client-registration`,`authorization-request`,`token-request`])this.checks.find(t=>t.id===e)||this.checks.push({id:e,name:`Expected Check Missing: ${e}`,description:`Expected Check Missing: ${e}`,status:`FAILURE`,timestamp:new Date().toISOString()});return this.checks}},at=class{constructor(){this.name=`auth/scope-from-www-authenticate`,this.description=`Tests that client uses scope parameter from WWW-Authenticate header when provided`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=`mcp:basic`,t=new P(this.checks,[e]),n=N(this.checks,this.authServer.getUrl,{tokenVerifier:t,onAuthorizationRequest:t=>{let n=(t.scope?t.scope.split(` `):[]).includes(e);this.checks.push({id:`scope-from-www-authenticate`,name:`Client scope selection from WWW-Authenticate header`,description:n?`Client correctly used the scope parameter from the WWW-Authenticate header`:`Client SHOULD use the scope parameter from the WWW-Authenticate header when provided`,status:n?`SUCCESS`:`WARNING`,timestamp:t.timestamp,specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY],details:{expectedScope:e,requestedScope:t.scope||`none`}})}});await this.authServer.start(n);let r=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:[e],includeScopeInWwwAuth:!0,tokenVerifier:t});return await this.server.start(r),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`scope-from-www-authenticate`)||this.checks.push({id:`scope-from-www-authenticate`,name:`Client scope selection from WWW-Authenticate header`,description:`Client did not complete authorization flow - scope check could not be performed`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY]}),this.checks}},ot=class{constructor(){this.name=`auth/scope-from-scopes-supported`,this.description=`Tests that client uses all scopes from scopes_supported when scope not in WWW-Authenticate header`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=[`mcp:basic`,`mcp:read`,`mcp:write`],t=new P(this.checks,e),n=N(this.checks,this.authServer.getUrl,{tokenVerifier:t,onAuthorizationRequest:t=>{let n=t.scope?t.scope.split(` `):[],r=e.every(e=>n.includes(e));this.checks.push({id:`scope-from-scopes-supported`,name:`Client scope selection from scopes_supported`,description:r?`Client correctly used all scopes from scopes_supported in PRM when scope not in WWW-Authenticate`:`Client SHOULD use all scopes from scopes_supported when scope not available in WWW-Authenticate header`,status:r?`SUCCESS`:`WARNING`,timestamp:t.timestamp,specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY],details:{scopesSupported:e.join(` `),requestedScope:t.scope||`none`,...r?{}:{missingScopes:e.filter(e=>!n.includes(e)).join(` `)}}})}});await this.authServer.start(n);let r=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:e,scopesSupported:e,includeScopeInWwwAuth:!1,tokenVerifier:t});return await this.server.start(r),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`scope-from-scopes-supported`)||this.checks.push({id:`scope-from-scopes-supported`,name:`Client scope selection from scopes_supported`,description:`Client did not complete authorization flow - scope check could not be performed`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY]}),this.checks}},st=class{constructor(){this.name=`auth/scope-omitted-when-undefined`,this.description=`Tests that client omits scope parameter when scopes_supported is undefined`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=new P(this.checks,[]),t=N(this.checks,this.authServer.getUrl,{tokenVerifier:e,onAuthorizationRequest:e=>{let t=!e.scope||e.scope.trim()===``;this.checks.push({id:`scope-omitted-when-undefined`,name:`Client scope omission when scopes_supported undefined`,description:t?`Client correctly omitted scope parameter when scopes_supported is undefined`:`Client SHOULD omit scope parameter when scopes_supported is undefined and scope not in WWW-Authenticate`,status:t?`SUCCESS`:`WARNING`,timestamp:e.timestamp,specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY],details:{scopeParameter:t?`omitted`:e.scope}})}});await this.authServer.start(t);let n=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:[],scopesSupported:void 0,includeScopeInWwwAuth:!1,tokenVerifier:e});return await this.server.start(n),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`scope-omitted-when-undefined`)||this.checks.push({id:`scope-omitted-when-undefined`,name:`Client scope omission when scopes_supported undefined`,description:`Client did not complete authorization flow - scope check could not be performed`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY]}),this.checks}},ct=class{constructor(){this.name=`auth/scope-step-up`,this.description=`Tests that client handles step-up authentication with different scope requirements per operation`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=`mcp:basic`,t=[`mcp:basic`,`mcp:write`],n=new P(this.checks,t),r=0,i=N(this.checks,this.authServer.getUrl,{tokenVerifier:n,onAuthorizationRequest:n=>{r++;let i=n.scope?n.scope.split(` `):[];if(r===1){let t=i.includes(e);this.checks.push({id:`scope-step-up-initial`,name:`Client initial scope selection for step-up auth`,description:t?`Client correctly used scope from WWW-Authenticate header for initial auth`:`Client SHOULD use the scope parameter from the WWW-Authenticate header`,status:t?`SUCCESS`:`WARNING`,timestamp:n.timestamp,specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY],details:{expectedScope:e,requestedScope:n.scope||`none`}})}else if(r===2){let e=t.every(e=>i.includes(e));this.checks.push({id:`scope-step-up-escalation`,name:`Client scope escalation for step-up auth`,description:e?`Client correctly escalated scopes for step-up authentication`:`Client SHOULD request additional scopes when receiving 403 with new scope requirements`,status:e?`SUCCESS`:`WARNING`,timestamp:n.timestamp,specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY],details:{expectedScopes:t.join(` `),requestedScope:n.scope||`none`}})}}});await this.authServer.start(i);let a=()=>`${this.server.getUrl()}/.well-known/oauth-protected-resource/mcp`,o=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:t,scopesSupported:t,includeScopeInWwwAuth:!0,authMiddleware:async(r,i,o)=>{let s=r.body;typeof s==`string`&&(s=JSON.parse(s));let c=s?.method;if(c===`initialize`||c?.startsWith(`notifications/`))return o();let l=r.headers.authorization;if(!l||!l.startsWith(`Bearer `))return i.status(401).set(`WWW-Authenticate`,`Bearer scope="${e}", resource_metadata="${a()}"`).json({error:`invalid_token`,error_description:`Missing Authorization header`});let u=l.substring(7),d=(await n.verifyAccessToken(u)).scopes||[],f=c===`tools/call`?t:[e];if(!f.every(e=>d.includes(e)))return i.status(403).set(`WWW-Authenticate`,`Bearer scope="${f.join(` `)}", resource_metadata="${a()}", error="insufficient_scope"`).json({error:`insufficient_scope`,error_description:`Token has insufficient scope`});o()},tokenVerifier:n});return await this.server.start(o),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){let e=this.checks.some(e=>e.id===`scope-step-up-initial`),t=this.checks.some(e=>e.id===`scope-step-up-escalation`);return e||this.checks.push({id:`scope-step-up-initial`,name:`Client initial scope selection for step-up auth`,description:`Client did not make an initial authorization request`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY]}),t||this.checks.push({id:`scope-step-up-escalation`,name:`Client scope escalation for step-up auth`,description:`Client did not make a second authorization request for scope escalation`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_SELECTION_STRATEGY]}),this.checks}},lt=class{constructor(){this.name=`auth/scope-retry-limit`,this.description=`Tests that client implements retry limits to prevent infinite authorization loops on repeated 403 responses`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=`mcp:admin`,t=new P(this.checks,[]),n=0,r=N(this.checks,this.authServer.getUrl,{tokenVerifier:t,onAuthorizationRequest:e=>{n++,this.checks.push({id:`scope-retry-auth-attempt`,name:`Authorization attempt ${n}`,description:`Client made authorization request attempt ${n}`,status:`INFO`,timestamp:e.timestamp,specReferences:[M.MCP_SCOPE_CHALLENGE_HANDLING],details:{attemptNumber:n,requestedScope:e.scope||`none`}})}});await this.authServer.start(r);let i=()=>`${this.server.getUrl()}/.well-known/oauth-protected-resource/mcp`,a=0,o=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:[e],scopesSupported:[e],includeScopeInWwwAuth:!0,authMiddleware:async(t,n,r)=>{let o=t.body;typeof o==`string`&&(o=JSON.parse(o));let s=o?.method;if(s===`initialize`||s?.startsWith(`notifications/`))return r();let c=t.headers.authorization;return!c||!c.startsWith(`Bearer `)?n.status(401).set(`WWW-Authenticate`,`Bearer scope="${e}", resource_metadata="${i()}"`).json({error:`invalid_token`,error_description:`Missing Authorization header`}):(a++,a>3?n.status(410).json({error:`test_complete`,error_description:`Test is over - client exceeded maximum retry attempts`}):n.status(403).set(`WWW-Authenticate`,`Bearer error="insufficient_scope", scope="${e}", resource_metadata="${i()}", error_description="Scope upgrade will never succeed"`).json({error:`insufficient_scope`,error_description:`Scope upgrade will never succeed`}))},tokenVerifier:t});return await this.server.start(o),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){let e=this.checks.filter(e=>e.id===`scope-retry-auth-attempt`).length;return e===0?this.checks.push({id:`scope-retry-limit`,name:`Client retry limit for scope escalation`,description:`Client did not make any authorization requests`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_CHALLENGE_HANDLING]}):e<=3?this.checks.push({id:`scope-retry-limit`,name:`Client retry limit for scope escalation`,description:`Client correctly limited retry attempts to ${e} (3 or fewer)`,status:`SUCCESS`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_CHALLENGE_HANDLING],details:{authorizationAttempts:e,maxAllowed:3}}):this.checks.push({id:`scope-retry-limit`,name:`Client retry limit for scope escalation`,description:`Client made ${e} authorization attempts (more than 3). Clients SHOULD implement retry limits to avoid infinite loops.`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_SCOPE_CHALLENGE_HANDLING],details:{authorizationAttempts:e,maxAllowed:3}}),this.checks}};function ut(e,t){return e?.startsWith(`Basic `)?`client_secret_basic`:t?`client_secret_post`:`none`}function dt(e){let t=e.substring(6);try{return Buffer.from(t,`base64`).toString(`utf-8`).includes(`:`)?{valid:!0}:{valid:!1,error:`missing colon separator`}}catch{return{valid:!1,error:`base64 decoding failed`}}}const ft={client_secret_basic:`HTTP Basic authentication (client_secret_basic)`,client_secret_post:`client_secret_post`,none:`no authentication (public client)`};var z=class{constructor(e){this.authServer=new I,this.server=new I,this.checks=[],this.expectedAuthMethod=e,this.name=`auth/token-endpoint-auth-${e===`client_secret_basic`?`basic`:e===`client_secret_post`?`post`:`none`}`,this.description=`Tests that client uses ${ft[e]} when server only supports ${e}`}async start(){this.checks=[],this.authorizationResource=void 0,this.tokenResource=void 0;let e=new P(this.checks,[]),t=N(this.checks,this.authServer.getUrl,{tokenVerifier:e,tokenEndpointAuthMethodsSupported:[this.expectedAuthMethod],onAuthorizationRequest:({resource:e})=>{this.authorizationResource=e},onTokenRequest:({authorizationHeader:e,body:t,timestamp:n})=>{this.tokenResource=t.resource;let r=t.client_secret,i=ut(e,r),a=i===this.expectedAuthMethod,o;if(i===`client_secret_basic`&&e){let t=dt(e);t.valid||(o=t.error)}let s=a&&!o?`SUCCESS`:`FAILURE`,c;return c=o?`Client sent Basic auth header but ${o}`:a?`Client correctly used ${ft[this.expectedAuthMethod]} for token endpoint`:`Client used ${i} but server only supports ${this.expectedAuthMethod}`,this.checks.push({id:`token-endpoint-auth-method`,name:`Token endpoint authentication method`,description:c,status:s,timestamp:n,specReferences:[M.OAUTH_2_1_TOKEN],details:{expectedAuthMethod:this.expectedAuthMethod,actualAuthMethod:i,hasAuthorizationHeader:!!e,hasBodyClientSecret:!!r,...o&&{formatError:o}}}),{token:`test-token-${Date.now()}`,scopes:[]}},onRegistrationRequest:()=>({clientId:`test-client-${Date.now()}`,clientSecret:this.expectedAuthMethod===`none`?void 0:`test-secret-${Date.now()}`,tokenEndpointAuthMethod:this.expectedAuthMethod})});await this.authServer.start(t);let n=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:[],tokenVerifier:e});return await this.server.start(n),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){let e=new Date().toISOString();return this.checks.some(e=>e.id===`token-endpoint-auth-method`)||this.checks.push({id:`token-endpoint-auth-method`,name:`Token endpoint authentication method`,description:`Client did not make a token request`,status:`FAILURE`,timestamp:e,specReferences:[M.OAUTH_2_1_TOKEN]}),this.addResourceParameterChecks(e),this.checks}addResourceParameterChecks(e){let t=[M.RFC_8707_RESOURCE_INDICATORS,M.MCP_RESOURCE_PARAMETER];if(!this.checks.some(e=>e.id===`resource-parameter-in-authorization`)){let n=!!this.authorizationResource;this.checks.push({id:`resource-parameter-in-authorization`,name:`Resource parameter in authorization request`,description:n?`Client included resource parameter in authorization request`:`Client MUST include resource parameter in authorization request per RFC 8707`,status:n?`SUCCESS`:`FAILURE`,timestamp:e,specReferences:t,details:{resource:this.authorizationResource||`not provided`}})}if(!this.checks.some(e=>e.id===`resource-parameter-in-token`)){let n=!!this.tokenResource;this.checks.push({id:`resource-parameter-in-token`,name:`Resource parameter in token request`,description:n?`Client included resource parameter in token request`:`Client MUST include resource parameter in token request per RFC 8707`,status:n?`SUCCESS`:`FAILURE`,timestamp:e,specReferences:t,details:{resource:this.tokenResource||`not provided`}})}if(!this.checks.some(e=>e.id===`resource-parameter-valid-uri`)){let n=this.authorizationResource||this.tokenResource;if(n){let r=this.validateCanonicalUri(n);this.checks.push({id:`resource-parameter-valid-uri`,name:`Resource parameter is valid canonical URI`,description:r.valid?`Resource parameter is a valid canonical URI (has scheme, no fragment)`:`Resource parameter is invalid: ${r.error}`,status:r.valid?`SUCCESS`:`FAILURE`,timestamp:e,specReferences:t,details:{resource:n,...r.error&&{error:r.error}}})}}if(!this.checks.some(e=>e.id===`resource-parameter-consistency`)&&this.authorizationResource&&this.tokenResource){let n=this.authorizationResource===this.tokenResource;this.checks.push({id:`resource-parameter-consistency`,name:`Resource parameter consistency`,description:n?`Resource parameter is consistent between authorization and token requests`:`Resource parameter MUST be consistent between authorization and token requests`,status:n?`SUCCESS`:`FAILURE`,timestamp:e,specReferences:t,details:{authorizationResource:this.authorizationResource,tokenResource:this.tokenResource}})}}validateCanonicalUri(e){try{return new URL(e).hash?{valid:!1,error:`contains fragment (not allowed per RFC 8707)`}:{valid:!0}}catch{return{valid:!1,error:`invalid URI format`}}}},pt=class extends z{constructor(){super(`client_secret_basic`)}},mt=class extends z{constructor(){super(`client_secret_post`)}},ht=class extends z{constructor(){super(`none`)}};const B=`conformance-test-client`,gt=`conformance-test-secret`;async function _t(){let{publicKey:e,privateKey:t}=await T.generateKeyPair(`ES256`,{extractable:!0});return{publicKey:e,privateKeyPem:await T.exportPKCS8(t)}}var vt=class{constructor(){this.name=`auth/client-credentials-jwt`,this.description=`Tests OAuth client_credentials flow with private_key_jwt authentication (SEP-1046)`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let{publicKey:e,privateKeyPem:t}=await _t(),n=N(this.checks,this.authServer.getUrl,{grantTypesSupported:[`client_credentials`],tokenEndpointAuthMethodsSupported:[`private_key_jwt`],tokenEndpointAuthSigningAlgValuesSupported:[`ES256`],onTokenRequest:async({grantType:t,body:n,timestamp:r,authBaseUrl:i})=>{if(t!==`client_credentials`)return this.checks.push({id:`client-credentials-grant-type`,name:`ClientCredentialsGrantType`,description:`Expected grant_type=client_credentials, got ${t}`,status:`FAILURE`,timestamp:r,specReferences:[M.OAUTH_2_1_CLIENT_CREDENTIALS,M.SEP_1046_CLIENT_CREDENTIALS]}),{error:`unsupported_grant_type`,errorDescription:`Only client_credentials grant is supported`};let a=n.client_assertion,o=n.client_assertion_type;if(o!==`urn:ietf:params:oauth:client-assertion-type:jwt-bearer`)return this.checks.push({id:`client-credentials-assertion-type`,name:`ClientCredentialsAssertionType`,description:`Invalid client_assertion_type: ${o}`,status:`FAILURE`,timestamp:r,specReferences:[M.RFC_JWT_CLIENT_AUTH]}),{error:`invalid_client`,errorDescription:`Invalid client_assertion_type`,statusCode:401};try{let t=i.replace(/\/+$/,``),o=`${t}/`,{payload:s}=await T.jwtVerify(a,e,{audience:[t,o],clockTolerance:30});if(s.iss!==B)return this.checks.push({id:`client-credentials-jwt-iss`,name:`ClientCredentialsJwtIss`,description:`JWT iss claim '${s.iss}' does not match expected client_id '${B}'`,status:`FAILURE`,timestamp:r,specReferences:[M.RFC_JWT_CLIENT_AUTH],details:{expected:B,actual:s.iss}}),{error:`invalid_client`,errorDescription:`JWT iss claim does not match expected client_id`,statusCode:401};if(s.sub!==B)return this.checks.push({id:`client-credentials-jwt-sub`,name:`ClientCredentialsJwtSub`,description:`JWT sub claim '${s.sub}' does not match expected client_id '${B}'`,status:`FAILURE`,timestamp:r,specReferences:[M.RFC_JWT_CLIENT_AUTH],details:{expected:B,actual:s.sub}}),{error:`invalid_client`,errorDescription:`JWT sub claim does not match expected client_id`,statusCode:401};this.checks.push({id:`client-credentials-jwt-verified`,name:`ClientCredentialsJwtVerified`,description:`Client successfully authenticated with signed JWT assertion`,status:`SUCCESS`,timestamp:r,specReferences:[M.OAUTH_2_1_CLIENT_CREDENTIALS,M.SEP_1046_CLIENT_CREDENTIALS,M.RFC_JWT_CLIENT_AUTH],details:{iss:s.iss,sub:s.sub,aud:s.aud}});let c=n.scope?n.scope.split(` `):[];return{token:`cc-token-${Date.now()}`,scopes:c}}catch(e){let t=e instanceof Error?e.message:String(e);return this.checks.push({id:`client-credentials-jwt-verified`,name:`ClientCredentialsJwtVerified`,description:`JWT verification failed: ${t}`,status:`FAILURE`,timestamp:r,specReferences:[M.RFC_JWT_CLIENT_AUTH],details:{error:t}}),{error:`invalid_client`,errorDescription:`JWT verification failed: ${t}`,statusCode:401}}}});await this.authServer.start(n);let r=F(this.checks,this.server.getUrl,this.authServer.getUrl);return await this.server.start(r),{serverUrl:`${this.server.getUrl()}/mcp`,context:{client_id:B,private_key_pem:t,signing_algorithm:`ES256`}}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`client-credentials-jwt-verified`)||this.checks.push({id:`client-credentials-jwt-verified`,name:`ClientCredentialsJwtVerified`,description:`Client did not make a client_credentials token request`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.OAUTH_2_1_CLIENT_CREDENTIALS,M.SEP_1046_CLIENT_CREDENTIALS]}),this.checks}},yt=class{constructor(){this.name=`auth/client-credentials-basic`,this.description=`Tests OAuth client_credentials flow with client_secret_basic authentication`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=N(this.checks,this.authServer.getUrl,{grantTypesSupported:[`client_credentials`],tokenEndpointAuthMethodsSupported:[`client_secret_basic`],onTokenRequest:async({grantType:e,body:t,timestamp:n,authorizationHeader:r})=>{if(e!==`client_credentials`)return this.checks.push({id:`client-credentials-grant-type`,name:`ClientCredentialsGrantType`,description:`Expected grant_type=client_credentials, got ${e}`,status:`FAILURE`,timestamp:n,specReferences:[M.OAUTH_2_1_CLIENT_CREDENTIALS,M.SEP_1046_CLIENT_CREDENTIALS]}),{error:`unsupported_grant_type`,errorDescription:`Only client_credentials grant is supported`};let i=r;if(!i||!i.startsWith(`Basic `))return this.checks.push({id:`client-credentials-basic-auth`,name:`ClientCredentialsBasicAuth`,description:`Missing or invalid Authorization header for Basic auth`,status:`FAILURE`,timestamp:n,specReferences:[M.SEP_1046_CLIENT_CREDENTIALS]}),{error:`invalid_client`,errorDescription:`Missing or invalid Authorization header`,statusCode:401};let a=i.slice(6),[o,s]=Buffer.from(a,`base64`).toString(`utf-8`).split(`:`);if(o!==B||s!==gt)return this.checks.push({id:`client-credentials-basic-auth`,name:`ClientCredentialsBasicAuth`,description:`Invalid client credentials`,status:`FAILURE`,timestamp:n,specReferences:[M.SEP_1046_CLIENT_CREDENTIALS],details:{clientId:o}}),{error:`invalid_client`,errorDescription:`Invalid client credentials`,statusCode:401};this.checks.push({id:`client-credentials-basic-auth`,name:`ClientCredentialsBasicAuth`,description:`Client successfully authenticated with client_secret_basic`,status:`SUCCESS`,timestamp:n,specReferences:[M.OAUTH_2_1_CLIENT_CREDENTIALS,M.SEP_1046_CLIENT_CREDENTIALS],details:{clientId:o}});let c=t.scope?t.scope.split(` `):[];return{token:`cc-token-${Date.now()}`,scopes:c}}});await this.authServer.start(e);let t=F(this.checks,this.server.getUrl,this.authServer.getUrl);return await this.server.start(t),{serverUrl:`${this.server.getUrl()}/mcp`,context:{client_id:B,client_secret:gt}}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`client-credentials-basic-auth`)||this.checks.push({id:`client-credentials-basic-auth`,name:`ClientCredentialsBasicAuth`,description:`Client did not make a client_credentials token request`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.OAUTH_2_1_CLIENT_CREDENTIALS,M.SEP_1046_CLIENT_CREDENTIALS]}),this.checks}},bt=class{constructor(){this.name=`auth/resource-mismatch`,this.description=`Tests that client rejects when PRM resource does not match server URL`,this.authServer=new I,this.server=new I,this.checks=[],this.authorizationRequestMade=!1}async start(){this.checks=[],this.authorizationRequestMade=!1;let e=new P(this.checks,[]),t=N(this.checks,this.authServer.getUrl,{tokenVerifier:e,tokenEndpointAuthMethodsSupported:[`none`],onAuthorizationRequest:()=>{this.authorizationRequestMade=!0},onRegistrationRequest:()=>({clientId:`test-client-${Date.now()}`,clientSecret:void 0,tokenEndpointAuthMethod:`none`})});await this.authServer.start(t);let n=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:[],tokenVerifier:e,prmResourceOverride:`https://evil.example.com/mcp`});return await this.server.start(n),{serverUrl:`${this.server.getUrl()}/mcp`}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){let e=new Date().toISOString(),t=[M.RFC_8707_RESOURCE_INDICATORS,M.MCP_RESOURCE_PARAMETER];if(!this.checks.some(e=>e.id===`resource-mismatch-rejected`)){let n=!this.authorizationRequestMade;this.checks.push({id:`resource-mismatch-rejected`,name:`Client rejects mismatched resource`,description:n?`Client correctly rejected authorization when PRM resource does not match server URL`:`Client MUST validate that PRM resource matches the server URL before proceeding with authorization`,status:n?`SUCCESS`:`FAILURE`,timestamp:e,specReferences:t,details:{prmResource:`https://evil.example.com/mcp`,expectedBehavior:`Client should NOT proceed with authorization`,authorizationRequestMade:this.authorizationRequestMade}})}return this.checks}};const V=`pre-registered-client`,xt=`pre-registered-secret`;var St=class{constructor(){this.name=`auth/pre-registration`,this.description=`Tests OAuth flow with pre-registered client credentials. Server does not support DCR.`,this.authServer=new I,this.server=new I,this.checks=[]}async start(){this.checks=[];let e=new P(this.checks,[]),t=N(this.checks,this.authServer.getUrl,{tokenVerifier:e,disableDynamicRegistration:!0,tokenEndpointAuthMethodsSupported:[`client_secret_basic`],onTokenRequest:({authorizationHeader:e,timestamp:t})=>{if(!e?.startsWith(`Basic `))return this.checks.push({id:`pre-registration-auth`,name:`Pre-registration authentication`,description:`Client did not use Basic authentication with pre-registered credentials`,status:`FAILURE`,timestamp:t,specReferences:[M.MCP_PREREGISTRATION]}),{error:`invalid_client`,errorDescription:`Missing or invalid Authorization header`,statusCode:401};let n=e.slice(6),[r,i]=Buffer.from(n,`base64`).toString(`utf-8`).split(`:`);return r!==V||i!==xt?(this.checks.push({id:`pre-registration-auth`,name:`Pre-registration authentication`,description:`Client used incorrect pre-registered credentials. Expected client_id '${V}', got '${r}'`,status:`FAILURE`,timestamp:t,specReferences:[M.MCP_PREREGISTRATION],details:{expectedClientId:V,actualClientId:r}}),{error:`invalid_client`,errorDescription:`Invalid pre-registered credentials`,statusCode:401}):(this.checks.push({id:`pre-registration-auth`,name:`Pre-registration authentication`,description:`Client correctly used pre-registered credentials when server does not support DCR`,status:`SUCCESS`,timestamp:t,specReferences:[M.MCP_PREREGISTRATION],details:{clientId:r}}),{token:`test-token-prereg-${Date.now()}`,scopes:[]})}});await this.authServer.start(t);let n=F(this.checks,this.server.getUrl,this.authServer.getUrl,{prmPath:`/.well-known/oauth-protected-resource/mcp`,requiredScopes:[],tokenVerifier:e});return await this.server.start(n),{serverUrl:`${this.server.getUrl()}/mcp`,context:{client_id:V,client_secret:xt}}}async stop(){await this.authServer.stop(),await this.server.stop()}getChecks(){return this.checks.some(e=>e.id===`pre-registration-auth`)||this.checks.push({id:`pre-registration-auth`,name:`Pre-registration authentication`,description:`Client did not make a token request`,status:`FAILURE`,timestamp:new Date().toISOString(),specReferences:[M.MCP_PREREGISTRATION]}),this.checks}};const H=[...$e,new nt,new rt,new it,new at,new ot,new st,new ct,new lt,new pt,new mt,new ht,new bt,new St],Ct=[new vt,new yt],wt=[new Ae,new Pe],Tt=[new he,new ge,new _e,new ve,new ye,new be,new xe,new Oe,new ke,new Se,new Ce,new we,new Te,new Ee,new De,new Ae,new je,new Pe,new Fe,new Me,new Ie,new Le,new Re,new ze,new Be,new Ve,new He,new Ue,new We,new Ge,new Ke,new Ze],Et=Tt.filter(e=>!wt.some(t=>t.name===e.name)),Dt=new Map(Tt.map(e=>[e.name,e])),Ot=[new se,new le,new fe,new pe,...H,...Ct],kt=[new se,new le,new fe,new pe,...H],At=new Map(Ot.map(e=>[e.name,e]));function U(e){return At.get(e)}function jt(e){return Dt.get(e)}function W(){return Array.from(At.keys())}function G(){return Array.from(Dt.keys())}function Mt(){return Et.map(e=>e.name)}function Nt(){return wt.map(e=>e.name)}function K(){return H.map(e=>e.name)}function Pt(){return kt.map(e=>e.name)}function Ft(){return Ct.map(e=>e.name)}const q={RESET:`\x1B[0m`,GRAY:`\x1B[90m`,GREEN:`\x1B[32m`,YELLOW:`\x1B[33m`,RED:`\x1B[31m`,BLUE:`\x1B[36m`};function It(e){switch(e){case`SUCCESS`:return q.GREEN;case`FAILURE`:return q.RED;case`WARNING`:return q.YELLOW;case`INFO`:return q.BLUE;default:return q.RESET}}function J(e){let t=Math.max(...e.map(e=>e.id.length)),n=Math.max(...e.map(e=>e.status.length));return e.map(e=>`${`${q.GRAY}${e.timestamp}${q.RESET}`} [${e.id.padEnd(t)}] ${`${It(e.status)}${e.status.padEnd(n)}${q.RESET}`} ${e.description}`+(e.id.includes(`outgoing`)&&e.id.includes(`response`)?`
`:``)).join(`
`)}function Y(e,t,n=``){let r=new Date().toISOString().replace(/[:.]/g,`-`),i=n?`${n}-${t}`:t;return a.join(e,`${i}-${r}`)}async function Lt(e,t,n,i=3e4,a){let o=e.split(` `),s=o[0],c=[...o.slice(1),n],l=``,u=``,d=!1,f={...process.env};return f.MCP_CONFORMANCE_SCENARIO=t,a&&(f.MCP_CONFORMANCE_CONTEXT=JSON.stringify({name:t,...a})),new Promise(e=>{let t=r(s,c,{shell:!0,stdio:`pipe`,env:f}),n=setTimeout(()=>{d=!0,t.kill()},i);t.stdout&&t.stdout.on(`data`,e=>{l+=e.toString()}),t.stderr&&t.stderr.on(`data`,e=>{u+=e.toString()}),t.on(`close`,t=>{clearTimeout(n),e({exitCode:t||0,stdout:l,stderr:u,timedOut:d})}),t.on(`error`,t=>{clearTimeout(n),e({exitCode:-1,stdout:l,stderr:u+`\nProcess error: ${t.message}`,timedOut:d})})})}async function Rt(e,t,n=3e4,r){let o;r&&(o=Y(r,t),await i.mkdir(o,{recursive:!0}));let s=U(t);console.error(`Starting scenario: ${t}`);let c=await s.start();console.error(`Executing client: ${e} ${c.serverUrl}`),c.context&&console.error(`With context: ${JSON.stringify(c.context)}`);try{let r=await Lt(e,t,c.serverUrl,n,c.context);r.exitCode!==0&&(console.error(`\nClient exited with code ${r.exitCode}`),r.stdout&&console.error(`\nStdout:\n${r.stdout}`),r.stderr&&console.error(`\nStderr:\n${r.stderr}`)),r.timedOut&&console.error(`\nClient timed out after ${n}ms`);let l=s.getChecks();return o&&(await i.writeFile(a.join(o,`checks.json`),JSON.stringify(l,null,2)),await i.writeFile(a.join(o,`stdout.txt`),r.stdout),await i.writeFile(a.join(o,`stderr.txt`),r.stderr),console.error(`Results saved to ${o}`)),{checks:l,clientOutput:r,resultDir:o}}finally{await s.stop()}}function zt(e,t=!1,n){let r=e.filter(e=>e.status===`SUCCESS`||e.status===`FAILURE`).length,i=e.filter(e=>e.status===`SUCCESS`).length,a=e.filter(e=>e.status===`FAILURE`).length,o=e.filter(e=>e.status===`WARNING`).length,s=n?.timedOut??!1,c=n?n.exitCode!==0:!1,l=a>0||o>0||s||c;return t?console.log(JSON.stringify(e,null,2)):console.error(`Checks:\n${J(e)}`),console.error(`
Test Results:`),console.error(`Passed: ${i}/${r}, ${a} failed, ${o} warnings`),s&&console.error(`
  CLIENT TIMED OUT - Test incomplete`),c&&!s&&console.error(`\n  CLIENT EXITED WITH ERROR (code ${n?.exitCode}) - Test may be incomplete`),a>0&&(console.error(`
Failed Checks:`),e.filter(e=>e.status===`FAILURE`).forEach(e=>{console.error(`  - ${e.name}: ${e.description}`),e.errorMessage&&console.error(`    Error: ${e.errorMessage}`)})),o>0&&(console.error(`
Warning Checks:`),e.filter(e=>e.status===`WARNING`).forEach(e=>{console.error(`  - ${e.name}: ${e.description}`),e.errorMessage&&console.error(`    Warning: ${e.errorMessage}`)})),l?console.error(`
 OVERALL: FAILED`):console.error(`
 OVERALL: PASSED`),{passed:i,failed:a,denominator:r,warnings:o,overallFailure:l}}async function Bt(e,t=!1,n){let r;n&&(r=Y(n,e),await i.mkdir(r,{recursive:!0}));let o=U(e);console.log(`Starting scenario: ${e}`);let s=await o.start();console.log(`Server URL: ${s.serverUrl}`),console.log(`Press Ctrl+C to stop...`);let c=async()=>{console.log(`
Shutting down...`);let e=o.getChecks();r&&await i.writeFile(a.join(r,`checks.json`),JSON.stringify(e,null,2)),t?console.log(`\nChecks:\n${JSON.stringify(e,null,2)}`):console.log(`\nChecks:\n${J(e)}`),r&&console.log(`\nChecks saved to ${r}/checks.json`),await o.stop(),process.exit(0)};process.on(`SIGINT`,c),process.on(`SIGTERM`,c),await new Promise(()=>{})}function Vt(e){return e.replace(/\*\*([^*]+)\*\*/g,`\x1B[1m$1\x1B[0m`).replace(/`([^`]+)`/g,`\x1B[2m$1\x1B[0m`)}async function Ht(e,t,n){let r;n&&(r=Y(n,t,`server`),await i.mkdir(r,{recursive:!0}));let o=jt(t);console.log(`Running client scenario '${t}' against server: ${e}`);let s=await o.run(e);return r&&(await i.writeFile(a.join(r,`checks.json`),JSON.stringify(s,null,2)),console.log(`Results saved to ${r}`)),{checks:s,resultDir:r,scenarioDescription:o.description}}function Ut(e,t,n=!1){let r=e.filter(e=>e.status===`SUCCESS`||e.status===`FAILURE`).length,i=e.filter(e=>e.status===`SUCCESS`).length,a=e.filter(e=>e.status===`FAILURE`).length,o=e.filter(e=>e.status===`WARNING`).length;return n?console.log(JSON.stringify(e,null,2)):console.log(`Checks:\n${J(e)}`),console.log(`
Test Results:`),console.log(`Passed: ${i}/${r}, ${a} failed, ${o} warnings`),a>0&&(console.log(`
=== Failed Checks ===`),e.filter(e=>e.status===`FAILURE`).forEach(e=>{console.log(`\n  - ${e.name}: ${e.description}`),e.errorMessage&&console.log(`    Error: ${e.errorMessage}`),console.log(`\n${Vt(t)}`)})),{passed:i,failed:a,denominator:r,warnings:o}}function Wt(e){console.log(`

=== SUMMARY ===`);let t=0,n=0;for(let r of e){let e=r.checks.filter(e=>e.status===`SUCCESS`).length,i=r.checks.filter(e=>e.status===`FAILURE`).length;t+=e,n+=i;let a=i===0?``:``;console.log(`${a} ${r.scenario}: ${e} passed, ${i} failed`)}return console.log(`\nTotal: ${t} passed, ${n} failed`),{totalPassed:t,totalFailed:n}}const Gt=n.object({command:n.string().min(1,`Command cannot be empty`).optional(),scenario:n.string().min(1,`Scenario cannot be empty`).refine(e=>U(e)!==void 0,e=>({message:`Unknown scenario '${e}'`})),timeout:n.string().transform(e=>parseInt(e,10)).pipe(n.number().positive(`Timeout must be a positive number`).int(`Timeout must be an integer`)).optional(),verbose:n.boolean().optional()}),Kt=n.object({url:n.string().url(`Invalid server URL`),scenario:n.string().refine(e=>jt(e)!==void 0,e=>({message:`Unknown scenario '${e}'`})).optional()});n.object({scenario:n.string().min(1,`Scenario cannot be empty`).refine(e=>U(e)!==void 0,e=>({message:`Unknown scenario '${e}'`}))});async function X(e){let t=ne(await i.readFile(e,`utf-8`));if(t==null)return{};if(typeof t!=`object`||Array.isArray(t))throw Error(`Invalid expected-failures file: expected an object with 'server' and/or 'client' keys`);let n={};if(t.server!==void 0){if(!Array.isArray(t.server))throw Error(`Invalid expected-failures file: 'server' must be an array of scenario names`);n.server=t.server.map(String)}if(t.client!==void 0){if(!Array.isArray(t.client))throw Error(`Invalid expected-failures file: 'client' must be an array of scenario names`);n.client=t.client.map(String)}return n}function Z(e,t){let n=new Set(t),r=[],i=[],a=[],o=new Set;for(let t of e){o.add(t.scenario);let e=t.checks.some(e=>e.status===`FAILURE`)||t.checks.some(e=>e.status===`WARNING`),s=n.has(t.scenario);e&&s?a.push(t.scenario):e&&!s?r.push(t.scenario):!e&&s&&i.push(t.scenario)}return{exitCode:r.length>0||i.length>0?1:0,unexpectedFailures:r,staleEntries:i,expectedFailures:a}}function Q(e){if(e.expectedFailures.length>0){console.log(`\n${q.YELLOW}Expected failures (in baseline):${q.RESET}`);for(let t of e.expectedFailures)console.log(`  ~ ${t}`)}if(e.staleEntries.length>0){console.log(`\n${q.RED}Stale baseline entries (now passing - remove from baseline):${q.RESET}`);for(let t of e.staleEntries)console.log(`   ${t}`)}if(e.unexpectedFailures.length>0){console.log(`\n${q.RED}Unexpected failures (not in baseline):${q.RESET}`);for(let t of e.unexpectedFailures)console.log(`   ${t}`)}e.exitCode===0?console.log(`\n${q.GREEN}Baseline check passed: all failures are expected.${q.RESET}`):(e.staleEntries.length>0&&console.log(`\n${q.RED}Baseline is stale: update your expected-failures file to remove passing scenarios.${q.RESET}`),e.unexpectedFailures.length>0&&console.log(`\n${q.RED}Unexpected failures detected: these scenarios are not in your expected-failures baseline.${q.RESET}`))}var qt=`0.1.11`;const $=new e;$.name(`conformance`).description(`MCP Conformance Test Suite`).version(qt),$.command(`client`).description(`Run conformance tests against a client implementation or start interactive mode`).option(`--command <command>`,`Command to run the client`).option(`--scenario <scenario>`,`Scenario to test`).option(`--suite <suite>`,`Run a suite of tests in parallel (e.g., "auth")`).option(`--timeout <ms>`,`Timeout in milliseconds`,`30000`).option(`--expected-failures <path>`,`Path to YAML file listing expected failures (baseline)`).option(`-o, --output-dir <path>`,`Save results to this directory`).option(`--verbose`,`Show verbose output`).action(async e=>{try{let t=parseInt(e.timeout,10),n=e.verbose??!1,r=e.outputDir;if(e.suite){e.command||(console.error(`--command is required when using --suite`),process.exit(1));let i={all:W,core:Pt,extensions:Ft,auth:K,metadata:et,"sep-835":()=>K().filter(e=>e.startsWith(`auth/scope-`))},a=e.suite.toLowerCase();i[a]||(console.error(`Unknown suite: ${a}`),console.error(`Available suites: ${Object.keys(i).join(`, `)}`),process.exit(1));let o=i[a]();console.log(`Running ${a} suite (${o.length} scenarios) in parallel...\n`);let s=await Promise.all(o.map(async n=>{try{return{scenario:n,checks:(await Rt(e.command,n,t,r)).checks,error:null}}catch(e){return{scenario:n,checks:[{id:n,name:n,description:`Failed to run scenario`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:e instanceof Error?e.message:String(e)}],error:e}}}));console.log(`
=== SUITE SUMMARY ===
`);let c=0,l=0,u=0;for(let e of s){let t=e.checks.filter(e=>e.status===`SUCCESS`).length,r=e.checks.filter(e=>e.status===`FAILURE`).length,i=e.checks.filter(e=>e.status===`WARNING`).length;c+=t,l+=r,u+=i;let a=r===0&&i===0?``:``,o=i>0?`, ${i} warnings`:``;console.log(`${a} ${e.scenario}: ${t} passed, ${r} failed${o}`),n&&r>0&&e.checks.filter(e=>e.status===`FAILURE`).forEach(e=>{console.log(`    - ${e.name}: ${e.errorMessage||e.description}`)})}if(console.log(`\nTotal: ${c} passed, ${l} failed, ${u} warnings`),e.expectedFailures){let t=Z(s,(await X(e.expectedFailures)).client??[]);Q(t),process.exit(t.exitCode)}process.exit(l>0||u>0?1:0)}e.scenario||(console.error(`Either --scenario or --suite is required`),console.error(`
Available client scenarios:`),W().forEach(e=>console.error(`  - ${e}`)),console.error(`
Available suites: all, core, extensions, auth, metadata, sep-835`),process.exit(1));let i=Gt.parse(e);i.command||(await Bt(i.scenario,n,r),process.exit(0));let a=await Rt(i.command,i.scenario,t,r),{overallFailure:o}=zt(a.checks,n,a.clientOutput);if(e.expectedFailures){let t=(await X(e.expectedFailures)).client??[],n=Z([{scenario:i.scenario,checks:a.checks}],t);Q(n),process.exit(n.exitCode)}process.exit(o?1:0)}catch(e){e instanceof t&&(console.error(`Validation error:`),e.errors.forEach(e=>{console.error(`  ${e.path.join(`.`)}: ${e.message}`)}),console.error(`
Available client scenarios:`),W().forEach(e=>console.error(`  - ${e}`)),process.exit(1)),console.error(`Client test error:`,e),process.exit(1)}}),$.command(`server`).description(`Run conformance tests against a server implementation`).requiredOption(`--url <url>`,`URL of the server to test`).option(`--scenario <scenario>`,`Scenario to test (defaults to active suite if not specified)`).option(`--suite <suite>`,`Suite to run: "active" (default, excludes pending), "all", or "pending"`,`active`).option(`--expected-failures <path>`,`Path to YAML file listing expected failures (baseline)`).option(`-o, --output-dir <path>`,`Save results to this directory`).option(`--verbose`,`Show verbose output (JSON instead of pretty print)`).action(async e=>{try{let t=Kt.parse(e),n=e.verbose??!1,r=e.outputDir;if(t.scenario){let i=await Ht(t.url,t.scenario,r),{failed:a}=Ut(i.checks,i.scenarioDescription,n);if(e.expectedFailures){let n=(await X(e.expectedFailures)).server??[],r=Z([{scenario:t.scenario,checks:i.checks}],n);Q(r),process.exit(r.exitCode)}process.exit(a>0?1:0)}else{let n=e.suite?.toLowerCase()||`active`,i;n===`all`?i=G():n===`active`||n===`core`?i=Mt():n===`pending`?i=Nt():(console.error(`Unknown suite: ${n}`),console.error(`Available suites: active, all, core, pending`),process.exit(1)),console.log(`Running ${n} suite (${i.length} scenarios) against ${t.url}\n`);let a=[];for(let e of i){console.log(`\n=== Running scenario: ${e} ===`);try{let n=await Ht(t.url,e,r);a.push({scenario:e,checks:n.checks})}catch(t){console.error(`Failed to run scenario ${e}:`,t),a.push({scenario:e,checks:[{id:e,name:e,description:`Failed to run scenario`,status:`FAILURE`,timestamp:new Date().toISOString(),errorMessage:t instanceof Error?t.message:String(t)}]})}}let{totalFailed:o}=Wt(a);if(e.expectedFailures){let t=Z(a,(await X(e.expectedFailures)).server??[]);Q(t),process.exit(t.exitCode)}process.exit(o>0?1:0)}}catch(e){e instanceof t&&(console.error(`Validation error:`),e.errors.forEach(e=>{console.error(`  ${e.path.join(`.`)}: ${e.message}`)}),console.error(`
Available server scenarios:`),G().forEach(e=>console.error(`  - ${e}`)),process.exit(1)),console.error(`Server test error:`,e),process.exit(1)}}),$.command(`list`).description(`List available test scenarios`).option(`--client`,`List client scenarios`).option(`--server`,`List server scenarios`).action(e=>{(e.server||!e.client&&!e.server)&&(console.log(`Server scenarios (test against a server):`),G().forEach(e=>console.log(`  - ${e}`))),(e.client||!e.client&&!e.server)&&((e.server||!e.client&&!e.server)&&console.log(``),console.log(`Client scenarios (test against a client):`),W().forEach(e=>console.log(`  - ${e}`)))}),$.parse();export{};